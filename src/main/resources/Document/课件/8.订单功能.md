1. 收货地址

做订单功能之前，我们做个简单的收货地址功能。收货地址功能其实很简单。就是增删改查。

## 1.1 后端

### ShopUserAddress

```java
package com.jg.pochi.pojo;

import lombok.Data;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/18 20:58
 * @Version 1.0
 */
@Data
public class ShopUserAddress implements Serializable {

    /**
     * ID，自增
     */
    private Long id;

    /**
     * 用户编号
     */
    private Long userId;

    /**
     * 收货人名称
     */
    private String name;

    /**
     * 手机号
     */
    private String phoneNumber;

    /**
     * 是否为默认，1是0否
     */
    private Integer defaultStatus;

    /**
     * 省份
     */
    private String province;

    /**
     * 城市
     */
    private String city;

    /**
     * 区县
     */
    private String region;

    /**
     * 详细地址
     */
    private String detailAddress;

    /**
     * 创建时间
     */
    private String createTime;

}

```



### ShopUserAddressController

```java
package com.jg.pochi.controller;

import com.jg.pochi.common.Result;
import com.jg.pochi.pojo.ShopUserAddress;
import com.jg.pochi.service.ShopUserAddressService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @Author: 杨德石
 * @Date: 2021/1/18 21:03
 * @Version 1.0
 */
@RestController
@RequestMapping("/address")
public class ShopUserAddressController {

    @Autowired
    private ShopUserAddressService shopUserAddressService;

    /**
     * 添加地址
     * @param shopUserAddress
     * @return
     */
    @RequestMapping(value = "/save", method = RequestMethod.POST)
    public Result<?> save(@RequestBody ShopUserAddress shopUserAddress) {
        shopUserAddressService.save(shopUserAddress);
        return new Result<>("添加成功");
    }

    /**
     * 修改地址
     * @param shopUserAddress
     * @return
     */
    @RequestMapping(value = "/update", method = RequestMethod.PUT)
    public Result<?> update(@RequestBody ShopUserAddress shopUserAddress) {
        shopUserAddressService.update(shopUserAddress);
        return new Result<>("修改成功");
    }

    /**
     * 删除
     * @param id
     * @return
     */
    @RequestMapping(value = "/delete/{id}", method = RequestMethod.DELETE)
    public Result<?> delete(@PathVariable Long id) {
        shopUserAddressService.delete(id);
        return new Result<>("删除成功");
    }

    /**
     * 根据id查询
     * @param id
     * @return
     */
    @RequestMapping(value = "/get/{id}", method = RequestMethod.GET)
    public Result<?> get(@PathVariable Long id) {
        ShopUserAddress shopUserAddress = shopUserAddressService.get(id);
        return new Result<>(shopUserAddress);
    }

    /**
     * 查询用户的收货地址列表
     * @return
     */
    @RequestMapping(value = "/getUserAddress", method = RequestMethod.GET)
    public Result<List<ShopUserAddress>> getUserAddress() {
        List<ShopUserAddress> list = shopUserAddressService.getUserAddress();
        return new Result<>(list);
    }


}

```



### ShopUserAddressService

```java
package com.jg.pochi.service;

import com.jg.pochi.pojo.ShopUserAddress;

import java.util.List;

/**
 * @Author: 杨德石
 * @Date: 2021/1/18 21:02
 * @Version 1.0
 */
public interface ShopUserAddressService {

    /**
     * 添加地址
     * @param shopUserAddress
     */
    void save(ShopUserAddress shopUserAddress);

    /**
     * 修改地址
     * @param shopUserAddress
     */
    void update(ShopUserAddress shopUserAddress);

    /**
     * 删除
     * @param id
     */
    void delete(Long id);

    /**
     * 根据id查询
     * @param id
     * @return
     */
    ShopUserAddress get(Long id);

    /**
     * 查询用户收货地址列表
     * @return
     */
    List<ShopUserAddress> getUserAddress();
}

```



### ShopUserAddressServiceImpl

```java
package com.jg.pochi.service.impl;

import com.jg.pochi.enums.StateEnums;
import com.jg.pochi.mapper.ShopUserAddressMapper;
import com.jg.pochi.pojo.ShopUserAddress;
import com.jg.pochi.service.ShopUserAddressService;
import com.jg.pochi.shiro.LoginUser;
import com.jg.pochi.utils.ShiroUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * @Author: 杨德石
 * @Date: 2021/1/18 21:02
 * @Version 1.0
 */
@Service
public class ShopUserAddressServiceImpl implements ShopUserAddressService {

    @Autowired
    private ShopUserAddressMapper shopUserAddressMapper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void save(ShopUserAddress shopUserAddress) {
        // 处理默认收货地址
        Integer defaultStatus = shopUserAddress.getDefaultStatus();
        LoginUser loginUser = ShiroUtils.getLoginUser();
        if(StateEnums.ADDRESS_DEFAULT.getCode().equals(defaultStatus)) {
            // 当前地址是默认的收货地址，将该用户其他的地址全部修改为非默认
            shopUserAddressMapper.updateNotDefaultByUserId(loginUser.getId());
        }
        shopUserAddress.setUserId(loginUser.getId());
        shopUserAddressMapper.save(shopUserAddress);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void update(ShopUserAddress shopUserAddress) {
        Integer defaultStatus = shopUserAddress.getDefaultStatus();
        LoginUser loginUser = ShiroUtils.getLoginUser();
        if(StateEnums.ADDRESS_DEFAULT.getCode().equals(defaultStatus)) {
            // 当前地址是默认的收货地址，将该用户其他的地址全部修改为非默认
            shopUserAddressMapper.updateNotDefaultByUserId(loginUser.getId());
        }
        shopUserAddressMapper.update(shopUserAddress);
    }

    @Override
    public void delete(Long id) {
        shopUserAddressMapper.delete(id);
    }

    @Override
    public ShopUserAddress get(Long id) {
        return shopUserAddressMapper.get(id);
    }

    @Override
    public List<ShopUserAddress> getUserAddress() {
        Long userId = ShiroUtils.getLoginUser().getId();
        return shopUserAddressMapper.getByUserId(userId);
    }
}

```



### ShopUserAddressMapper

```java
package com.jg.pochi.mapper;

import com.jg.pochi.pojo.ShopUserAddress;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * @Author: 杨德石
 * @Date: 2021/1/18 21:01
 * @Version 1.0
 */
@Component
public interface ShopUserAddressMapper {

    /**
     * 添加
     * @param shopUserAddress
     */
    void save(ShopUserAddress shopUserAddress);

    /**
     * 修改
     * @param shopUserAddress
     */
    void update(ShopUserAddress shopUserAddress);

    /**
     * 删除
     * @param id
     */
    void delete(Long id);

    /**
     * 根据id查询
     * @param id
     * @return
     */
    ShopUserAddress get(Long id);

    /**
     * 根据用户ID查询
     * @param userId
     * @return
     */
    List<ShopUserAddress> getByUserId(Long userId);

    /**
     * 根据用户ID将该用户所有的收货地址修改为非默认地址
     * @param id
     */
    void updateNotDefaultByUserId(Long id);
}

```



### ShopUserAddressMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.jg.pochi.mapper.ShopUserAddressMapper">
    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.jg.pochi.pojo.ShopUserAddress">
        <id column="id" property="id"/>
        <result column="user_id" property="userId"/>
        <result column="name" property="name"/>
        <result column="phone_number" property="phoneNumber"/>
        <result column="default_status" property="defaultStatus"/>
        <result column="province" property="province"/>
        <result column="city" property="city"/>
        <result column="region" property="region"/>
        <result column="detail_address" property="detailAddress"/>
        <result column="create_time" property="createTime"/>
    </resultMap>
    <insert id="save">
        insert into shop_user_address(user_id, name, phone_number, default_status, province, city, region,
                                      detail_address)
        VALUES (#{userId}, #{name}, #{phoneNumber}, #{defaultStatus}, #{province}, #{city}, #{region},
                #{detailAddress})
    </insert>
    <update id="update">
        update shop_user_address
        <set>
            <if test="name!=null and name!=''">
                name = #{name},
            </if>
            <if test="phoneNumber!=null and phoneNumber!=''">
                phone_number = #{phoneNumber},
            </if>
            <if test="defaultStatus!=null">
                default_status = #{defaultStatus},
            </if>
            <if test="province!=null and province!=''">
                province = #{province},
            </if>
            <if test="city!=null and city!=''">
                city = #{city},
            </if>
            <if test="region!=null and region!=''">
                region = #{region},
            </if>
            <if test="detailAddress!=null and detailAddress!=''">
                detail_address = #{detailAddress},
            </if>
        </set>
        where id = #{id}
    </update>
    <update id="updateNotDefaultByUserId">
        update shop_user_address
        set default_status = 0
        where user_id = #{userId}
          and default_status = 1
    </update>
    <delete id="delete">
        delete
        from shop_user_address
        where id = #{id}
    </delete>
    <select id="get" resultMap="BaseResultMap">
        select id,
               user_id,
               name,
               phone_number,
               default_status,
               province,
               city,
               region,
               detail_address
        from shop_user_address
        where id = #{id}
    </select>
    <select id="getByUserId" resultMap="BaseResultMap">
        select id,
               user_id,
               name,
               phone_number,
               default_status,
               province,
               city,
               region,
               detail_address
        from shop_user_address
        where user_id = #{userId}
        order by default_status desc, create_time desc
    </select>


</mapper>

```



## 1.2 前端

### API

创建 `shopUserAddress.js`，内容如下

```js
import request from '@/utils/request'
const groupName = 'address'
export default {
  /**
   * 添加
   */
  save(sysUser) {
    return request({
      url: `/${groupName}/save`,
      method: 'post',
      data: sysUser
    })
  },
  /**
  * 修改
  */
  update(sysUser) {
    return request({
      url: `/${groupName}/update`,
      method: 'put',
      data: sysUser
    })
  },
  /**
   * 查询用户收货地址
   */
  getUserAddress() {
    return request({
      url: `/${groupName}/getUserAddress`,
      method: 'get'
    })
  },
  /**
   * 删除
   */
  deleteById(id) {
    return request({
      url: `/${groupName}/delete/${id}`,
      method: 'delete'
    })
  },
  /**
   * 根据id查询
   */
  get(id) {
    return request({
      url: `/${groupName}/get/${id}`,
      method: 'get'
    })
  }
}

```

### 页面

#### 添加

页面在 `pages/AddressEdit/AddressEdit.vue`

这里的 **所在地区** 需要修改成省市县选择器。本课程直接使用现成的 **`simple-address`**。[插件地址](https://ext.dcloud.net.cn/plugin?id=1084)

这种方式在生产环境是不推荐的，建议感兴趣的同学自己提供个加载数据的接口去获取省市县。

```vue
<template>
	<view class="page">
		<view class="address-input">
			<view class="list-input">
				<view class="title">
					<text>收货人</text>
				</view>
				<view class="content">
					<input v-model="address.name" type="text" placeholder="请填写收货人姓名">
				</view>
			</view>
			<view class="list-input">
				<view class="title">
					<text>手机号</text>
				</view>
				<view class="content">
					<input v-model="address.phoneNumber" type="tel" placeholder="请填写收货人手机号">
				</view>
			</view>
			<view class="list-input">
				<view class="title">
					<text>所在地区</text>
				</view>
				<view class="content">
					<input v-model="addressAddr" @focus="openSelect" type="tel" placeholder="省市区县/乡镇等">
				</view>
			</view>
			<view class="list-textarea">
				<view class="title">
					<text>详细地址</text>
				</view>
				<view class="content">
					<textarea v-model="address.detailAddress" type="tel" placeholder="街道/楼牌号等" />
				</view>
			</view>
		</view>
		<view class="tag-default">
			<view class="default-address">
				<view class="title">
					<text>默认地址</text>
				</view>
				<view class="switch-default">
					<switch v-model="defaultStatus" @change="changeDefault" class="red sm" color="#0077EE !important" :checked="defaultStatus"></switch>
				</view>
			</view>
		</view>
		<view class="footer-btn" @click="submit">
			<view class="btn">
				<text>保存</text>
			</view>
		</view>
		<simple-address ref="simpleAddress" :pickerValueDefault="cityPickerValueDefault" @onConfirm="confirmAddress" themeColor='#007AFF'></simple-address>
	</view>
</template>

<script>
	import addressApi from '@/api/shop-user-address.js'
	export default {
		data() {
			return {
				addressType: '2',
				// 地址 
				address: {
					province: '',
					city: '',
					region: ''
				},
				// 是否默认
				defaultStatus: true,
				// 省市县选择器默认选中
				cityPickerValueDefault: [0,0,1]
			};
		},
		onLoad(params) {
			this.address.defaultStatus = 1
			this.addressType = params.type||'2';
			uni.setNavigationBarTitle({
				title: this.addressType === '1' ? '编辑收货地址':'新建收货地址'
			})
			if(this.addressType === '1') {
				// 修改
				addressApi.get(params.id).then(res=>{
					this.address = res.data
					this.defaultStatus = this.address.defaultStatus === 1
				})
			}
		},
		computed:{
			addressAddr() {
				if(this.address.province) {
					return this.address.province + '-' + this.address.city + '-' + this.address.region
				}else {
					return ''
				}
			}
		},
		methods: {
			// 选中地址触发
			confirmAddress(e) {
				const addressArr = e.labelArr
				this.address.province = addressArr[0]
				this.address.city = addressArr[1]
				this.address.region = addressArr[2]
			},
			// 打开省市县选择器
			openSelect() {
				this.$refs.simpleAddress.open()
			},
			// 提交表单
			submit() {
				if(this.addressType === '1') {
					this.update()
				}else {
					this.save()
				}
			},
			// 修改默认地址
			changeDefault(e) {
				this.address.defaultStatus = e.target.value ? 1:0
			},
			// 修改地址
			update() {
				addressApi.update(this.address).then(res=>{
					uni.showToast({
						title:res.msg
					})
					setTimeout(()=>{
						uni.navigateBack()
					}, 500)
				})
			},
			// 添加地址
			save() {
				addressApi.save(this.address).then(res=>{
					uni.showToast({
						title:res.msg
					})
					setTimeout(()=>{
						uni.navigateBack()
					}, 500)
				})
			}
		}
	}
</script>

<style scoped lang="scss">
	@import 'AddressEdit.scss';
</style>

```

#### 列表

页面在 `pages/AddressList/AddressList.vue`

删除功能我们使用滑动操作组件，[组件地址](https://ext.dcloud.net.cn/plugin?id=181)

```vue
<template>
	<view class="page">
		<!-- 地址列表 -->
		<view class="address-list">
			<view class="list" v-for="(item,index) in addressList" :key="index">
				<view class="name-phone">
					<view class="name">
						<text class="one-omit">{{item.name}}</text>
					</view>
					<view class="phone">
						<text>{{item.phoneNumber}}</text>
						<text class="tag" v-if="item.defaultStatus === 1">默认</text>
					</view>
				</view>
				<view class="address-edit">
					<view class="address">
						<text>{{item.province+item.city+item.region+item.detailAddress}}</text>
					</view>
					<view class="edit" @click.stop="onAddressEdit(1, item.id)">
						<text class="iconfont icon-edit1"></text>
					</view>
				</view>
			</view>
		</view>
		<!-- 添加地址 -->
		<view class="add-address">
			<view class="btn" @click="onAddressEdit(2)">
				<text>新建收货地址</text>
			</view>
		</view>
	</view>
</template>

<script>
	import addressApi from '@/api/shop-user-address.js'
	export default {
		data() {
			return {
				// 地址列表
				addressList: []
			};
		},
		onShow() {
			this.getAddressList()
		},
		methods:{
			// 查询地址列表
			getAddressList() {
				addressApi.getUserAddress().then(res=>{
					this.addressList = res.data
				})
			},
			/**
			 * 编辑地址点击
			 */
			onAddressEdit(type, id){
				uni.navigateTo({
					url: `/pages/AddressEdit/AddressEdit?type=${type}&id=${id}`,
				})
			}
		}
	}
</script>

<style scoped lang="scss">
	@import 'AddressList.scss';
</style>

```



# 2. 微信支付

由于微信支付只能由企业账号申请，**个人账号无法申请**，因此本章的内容请大家认真观看，做好笔记。即使现在没法实战，将来在企业中也有一展拳脚的机会。

[官方文档](https://pay.weixin.qq.com/wiki/doc/apiv3/wxpay/pages/api.shtml)

微信支付目前已有 V3 版本文档，V3文档遵循统一的Restful风格，使用JSON进行交互，而V2版本是使用XML交互。V2版本所有的业务都有V3对应的版本，新业务将只支持V3，因此如果是从0对接微信支付，推荐使用V3版本。本课程考虑到大部分公司还是使用V2版本，因此本次也采用V2版本进行开发。

[V2版本文档](https://pay.weixin.qq.com/wiki/doc/api/index.html)

小程序开通微信支付，即申请或复用微信支付商户号。申请完小程序后，登录小程序后台（mp.weixin.qq.com）。点击左侧导航栏的微信支付，在页面中进行开通。（开通申请要求小程序已发布上线）。开通成功后，绑定商户号即可。

## 2.1 支付流程

小程序支付流程如下图所示。

![wxapy](https://pay.weixin.qq.com/wiki/doc/api/img/wxa-7-2.jpg)

由图片可知，我们需要先在后端调用下单API去生成订单，之后小程序调起微信支付对该订单进行支付，最后等待微信回调即可。



## 2.2 统一下单接口

首先第一步是我们的下单操作，后台生成订单后，小程序才能通过订单号去调起支付。

[文档地址](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_1&index=1)

引入微信支付依赖

```xml
        <dependency>
            <groupId>com.github.wxpay</groupId>
            <artifactId>wxpay-sdk</artifactId>
            <version>0.0.3</version>
        </dependency>
```



我们先在`application.yml`里把商户号和秘钥进行配置，并将相应的属性加在`WeChatConfig`里

**application.yml**

```yaml
wechat:
  mchId: aaaa # 商户号
  mchSecret: aaaa # 秘钥
  notifyUrl: https://huaji.picp.vip/notify/payNotify
```

**WeChatConfig**

```java
package com.jg.pochi.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * @Author: 杨德石
 * @Date: 2020/10/17 20:59
 * @Version 1.0
 */
@Data
@Component
@ConfigurationProperties(prefix = "wechat")
public class WeChatConfig {

    private String appId;
    private String appSecret;
    private String loginUrl;
    private String accessTokenUrl;
    private String pushUrl;
    private String mchId;
    private String mchSecret;

    public String getAuthUrl(String code) {
        return loginUrl + "appid=" + appId + "&secret=" + appSecret + "&js_code=" + code;
    }

    public String resolveAccessTokenUrl() {
        return accessTokenUrl + "appid=" + appId + "&secret=" + appSecret;
    }

    public String getPushMessageUrl(String accessToken) {
        return pushUrl + accessToken;
    }

}

```

接下来，我们根据文档中的必须字段去创建实体类，注意：昂trade_type=JSAPI时，openid也必传

**WxOrderDto**

```java
package com.jg.pochi.pojo.dto;

import com.alibaba.fastjson.annotation.JSONField;
import lombok.Data;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/15 11:30
 * @Version 1.0
 */
@Data
public class WxOrderDto implements Serializable {

    @JSONField(name = "appid")
    private String appId;

    @JSONField(name = "mch_id")
    private String mchId;

    @JSONField(name = "nonce_str")
    private String nonceStr;

    @JSONField(name = "sign")
    private String sign;

    @JSONField(name = "body")
    private String body;

    @JSONField(name = "out_trade_no")
    private String outTradeNo;

    @JSONField(name = "total_fee")
    private String totalFee;

    @JSONField(name = "spbill_create_ip")
    private String spbillCreateIp;

    @JSONField(name = "notify_url")
    private String notifyUrl;

    @JSONField(name = "trade_type")
    private String tradeType;

    @JSONField(name = "openid")
    private String openId;



}

```

其中下单地址和回调地址我们也需要配置到配置文件中。

**application.yml**

```yaml
  orderUrl: https://api.mch.weixin.qq.com/pay/unifiedorder
  notifyUrl: https://huaji.picp.vip/notify/payNotify
```

下面我们编写测试方法。在test下创建`WxTest`类进行编写。

其中，签名需要使用特定的签名算法

[签名算法](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=4_3)

**WxTest**

```java
package com.jg.pochi;

import com.alibaba.fastjson.JSON;
import com.github.wxpay.sdk.WXPayUtil;
import com.jg.pochi.config.WeChatConfig;
import com.jg.pochi.pojo.dto.WxOrderDto;
import com.jg.pochi.pojo.vo.WxOrderVo;
import com.jg.pochi.utils.HttpUtils;
import com.jg.pochi.utils.Md5Utils;
import com.jg.pochi.utils.StringUtils;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.net.InetAddress;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.UUID;

/**
 * @Author: 杨德石
 * @Date: 2021/1/15 11:27
 * @Version 1.0
 */
@SpringBootTest
@RunWith(SpringRunner.class)
public class WxTest {

    @Autowired
    private WeChatConfig weChatConfig;

    @Test
    public void testParseXml() throws Exception {
        String xml = "<xml><return_code><![CDATA[SUCCESS]]></return_code>\n" +
                "<return_msg><![CDATA[OK]]></return_msg>\n" +
                "<appid><![CDATA[wx0860003221643da0]]></appid>\n" +
                "<mch_id><![CDATA[1587074611]]></mch_id>\n" +
                "<nonce_str><![CDATA[p1uWetbBnknbs0g6]]></nonce_str>\n" +
                "<sign><![CDATA[014FBD8EE53F58F7E8557C6076CAC580]]></sign>\n" +
                "<result_code><![CDATA[SUCCESS]]></result_code>\n" +
                "<prepay_id><![CDATA[wx151426424757312e1bd1356e51c1bb0000]]></prepay_id>\n" +
                "<trade_type><![CDATA[JSAPI]]></trade_type>\n" +
                "</xml>";
        Map<String, String> map = WXPayUtil.xmlToMap(xml);
        System.out.println(JSON.toJSONString(map));
    }

    @Test
    public void testCreateOrder() throws Exception {
        WxOrderDto wxOrderDto = new WxOrderDto();
        wxOrderDto.setAppId(weChatConfig.getAppId());
        wxOrderDto.setMchId(weChatConfig.getMchId());
        wxOrderDto.setNonceStr(UUID.randomUUID().toString().replace("-", ""));
        wxOrderDto.setBody("下单");
        wxOrderDto.setOutTradeNo(UUID.randomUUID().toString().replace("-", ""));
        wxOrderDto.setTotalFee(1);
        wxOrderDto.setSpbillCreateIp(InetAddress.getLocalHost().getHostAddress());
        wxOrderDto.setTradeType("JSAPI");
        wxOrderDto.setNotifyUrl(weChatConfig.getNotifyUrl());
        wxOrderDto.setOpenId("o0OpY4zdWx85GGO8IHTsG6a8MBkw");
        wxOrderDto.setSign(getSign(JSON.parseObject(JSON.toJSONString(wxOrderDto), TreeMap.class)));
        String xmlParam = getXmlParam(wxOrderDto);
        System.out.println(xmlParam);
        String body = HttpUtils.post(weChatConfig.getOrderUrl(), xmlParam).body();
        System.out.println(body);
        Map<String, String> map = WXPayUtil.xmlToMap(body);
        WxOrderVo wxOrderVo = buildOrder(map.get("prepay_id"), wxOrderDto);
        System.out.println(JSON.toJSONString(wxOrderVo));
    }

    private WxOrderVo buildOrder(String prepayId, WxOrderDto wxOrderDto) {
        WxOrderVo vo = new WxOrderVo();
        vo.setAppId(wxOrderDto.getAppId());
        vo.setSignType("MD5");
        vo.setTimeStamp(System.currentTimeMillis() / 1000 + "");
        vo.setNonceStr(UUID.randomUUID().toString().replace("-", ""));
        vo.setPack("prepay_id=" + prepayId);
        vo.setPaySign(getSign(JSON.parseObject(JSON.toJSONString(vo), TreeMap.class)));
        return vo;
    }

    private String getXmlParam(WxOrderDto wxOrderDto) {
        try {
            return WXPayUtil.mapToXml(JSON.parseObject(JSON.toJSONString(wxOrderDto), Map.class));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private String getSign(TreeMap<String, Object> param) {
        // 转换成treeMap排序
        List<String> list = new ArrayList<>();
        for (Map.Entry<String, Object> entry : param.entrySet()) {
            if (entry.getValue() == null || "".equals(entry.getValue().toString())) {
                continue;
            }
            list.add(entry.getKey() + "=" + entry.getValue());
        }
        String stringA = StringUtils.join(list, "&");
        String signTemp = stringA + "&key=" + weChatConfig.getMchSecret();
        System.out.println(signTemp);
        return Md5Utils.toMD5(signTemp).toUpperCase();
    }

}

```

## 2.3 小程序调起微信支付

后台通过统一下单接口创建订单完毕后，需要将prepay_id记录下来，接下来我们在小程序调用唤起支付的API。

[官方接口文档](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&index=3)

[uni-app官方文档](https://uniapp.dcloud.io/api/plugins/payment?id=requestpayment)

可以看到，参数还是较为复杂的，因此我们可以在后端组装后返回给前端。

创建WxOrderVo，属性为调起支付需要的属性。

**WxOrderVo**

```java
package com.jg.pochi.pojo.vo;

import com.alibaba.fastjson.annotation.JSONField;
import lombok.Data;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/15 14:51
 * @Version 1.0
 */
@Data
public class WxOrderVo implements Serializable {

    private String appId;

    private String timeStamp;

    private String nonceStr;

    @JSONField(name = "package")
    private String pack;

    private String signType;

    private String paySign;

}

```

接下来在我们下单的方法后面，追加我们构造订单数据的代码

**WxTest**

````java

    @Test
    public void testCreateOrder() throws Exception {
        WxOrderDto wxOrderDto = new WxOrderDto();
        wxOrderDto.setAppId(weChatConfig.getAppId());
        wxOrderDto.setMchId(weChatConfig.getMchId());
        wxOrderDto.setNonceStr(UUID.randomUUID().toString().replace("-", ""));
        wxOrderDto.setBody("下单");
        wxOrderDto.setOutTradeNo(UUID.randomUUID().toString().replace("-", ""));
        wxOrderDto.setTotalFee(1);
        wxOrderDto.setSpbillCreateIp(InetAddress.getLocalHost().getHostAddress());
        wxOrderDto.setTradeType("JSAPI");
        wxOrderDto.setNotifyUrl(weChatConfig.getNotifyUrl());
        wxOrderDto.setOpenId("o0OpY4zdWx85GGO8IHTsG6a8MBkw");
        wxOrderDto.setSign(getSign(JSON.parseObject(JSON.toJSONString(wxOrderDto), TreeMap.class)));
        String xmlParam = getXmlParam(wxOrderDto);
        System.out.println(xmlParam);
        String body = HttpUtils.post(weChatConfig.getOrderUrl(), xmlParam).body();
        System.out.println(body);
        Map<String, String> map = WXPayUtil.xmlToMap(body);
        WxOrderVo wxOrderVo = buildOrder(map.get("prepay_id"), wxOrderDto);
        System.out.println(JSON.toJSONString(wxOrderVo));
    }
````

接下来我们使用这里输出的内容去测试唤起微信支付。先定位到小程序的任意页面，在onShow里去唤起支付。

```vue
			wx.requestPayment({
				"appId": "aaaa",
				"nonceStr": "214e1ca3bee14754a27faa6141de1c98",
				"package": "prepay_id=wx1515332958176817970a08ce9a710b0000",
				"paySign": "C1D83F70AC3F5897C3E75F6B947C80FA",
				"signType": "MD5",
				"timeStamp": "1610696009",
				"complete": function(res) {
					console.log(res)
				}
			})
```

## 2.4 支付回调

支付成功后，我们需要提供一个回调接口用来接收支付的信息，在回调里，我们可以去修改订单状态，并推送消息通知用户。

[接口文档](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_7)

从文档中可以看出，参数是比较多的，虽然微信支付的依赖包给了我们xml转map的方法，但是map操作起来并不方便，我们这里还是需要创建一个实体

**PayNotifyDto**

```java
package com.jg.pochi.pojo.dto;

import com.alibaba.fastjson.annotation.JSONField;
import lombok.Data;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/15 16:33
 * @Version 1.0
 */
@Data
public class PayNotifyDto implements Serializable {

    @JSONField(name = "transaction_id")
    private String transactionId;
    @JSONField(name = "nonce_str")
    private String nonceStr;
    @JSONField(name = "bank_type")
    private String bankType;
    @JSONField(name = "openid")
    private String openId;
    @JSONField(name = "sign")
    private String sign;
    @JSONField(name = "fee_type")
    private String feeType;
    @JSONField(name = "mch_id")
    private String mchId;
    @JSONField(name = "cash_fee")
    private String cashFee;
    @JSONField(name = "out_trade_no")
    private String outTradeNo;
    @JSONField(name = "appid")
    private String appId;
    @JSONField(name = "total_fee")
    private String totalFee;
    @JSONField(name = "trade_type")
    private String tradeType;
    @JSONField(name = "result_code")
    private String resultCode;
    @JSONField(name = "time_end")
    private String timeEnd;
    @JSONField(name = "is_subscribe")
    private String isSubscribe;
    @JSONField(name = "return_code")
    private String returnCode;

}

```



我们提供一个 `NotifyController` 用来接收回调信息。

**NotifyController**

```java
package com.jg.pochi.controller;

import com.alibaba.fastjson.JSON;
import com.github.wxpay.sdk.WXPayUtil;
import com.jg.pochi.config.WeChatConfig;
import com.jg.pochi.pojo.dto.PayNotifyDto;
import com.jg.pochi.utils.Md5Utils;
import com.jg.pochi.utils.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * @Author: 杨德石
 * @Date: 2021/1/15 15:51
 * @Version 1.0
 */
@RestController
@RequestMapping("/notify")
public class NotifyController {
    @Autowired
    private WeChatConfig weChatConfig;

    @RequestMapping(value = "/payNotify")
    public String notify(HttpServletRequest request) {
        InputStream is = null;
        try {
            is = request.getInputStream();
            // 将InputStream转换成String
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            StringBuilder sb = new StringBuilder();
            String line = null;
            while ((line = reader.readLine()) != null) {
                sb.append(line).append("\n");
            }
            Map<String, String> data = WXPayUtil.xmlToMap(sb.toString());
            // 验签
            PayNotifyDto payNotifyDto = JSON.parseObject(JSON.toJSONString(data), PayNotifyDto.class);
            data.remove("sign");
            String sign = getSign(new TreeMap<>(data));
            if(payNotifyDto.getSign().equals(sign)) {
                System.out.println("验签通过");
            }
            return getSuccessResult();
        } catch (Exception e) {
            System.out.println("微信手机支付回调通知失败：" + e);
        } finally {
            if (is != null) {
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return getErrorResult();
    }

    private String getSuccessResult() {
        Map<String, String> map = new HashMap<>();
        map.put("return_code", "SUCCESS");
        try {
            return WXPayUtil.mapToXml(map);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private String getErrorResult() {
        Map<String, String> map = new HashMap<>();
        map.put("return_code", "FAIL");
        try {
            return WXPayUtil.mapToXml(map);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private String getSign(TreeMap<String, String> param) {
        // 转换成treeMap排序
        List<String> list = new ArrayList<>();
        for (Map.Entry<String, String> entry : param.entrySet()) {
            if (entry.getValue() == null || "".equals(entry.getValue().toString())) {
                continue;
            }
            list.add(entry.getKey() + "=" + entry.getValue());
        }
        String stringA = StringUtils.join(list, "&");
        String signTemp = stringA + "&key=" + weChatConfig.getMchSecret();
        System.out.println(signTemp);
        return Md5Utils.toMD5(signTemp).toUpperCase();
    }
}

```

之后，需要从shiro的配置中把回调接口放行。

> 微信的回调并不能保证一定能成功，此外，回调的及时性也不一定高，因此微信提供了主动查询订单的接口。
>
> [接口文档](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_2)
>
> 我们可以提供一个定时任务，约定超过半小时的订单就需要主动查询，定时任务主动扫表，查询出超过半小时还没有改变状态的订单，然后主动查询订单情况，通知用户。
>
> 本次课程就不再对接该接口了，实际项目的生产环境为了保险起见一定要对接。

# 3. 订单

下单功能较为复杂，我们拆分成几个步骤进行分析。

提交订单 -> 立即支付 -> 支付成功 -> 消息推送

## 3.1 提交订单

提交订单功能是整个步骤中最复杂的，我们拆分成前后端步骤

### 3.1.1 后端

后端步骤如下：

1. 前端提交订单参数：收货地址编号、商品编号、购买数量、优惠券编号等
2. 商品扣减库存
3. 计算总金额，如果用了优惠券就扣除优惠券的金额
4. 存入订单表、订单项表、订单历史表
5. 优惠券状态变更为已使用

这里需要注意4点。

1. 金额前端需要计算，但是后端也必须计算
2. 订单提交后商品库存需要扣减，否则可能会超卖
3. 积分在提交订单时不进行增加，用户订单统计也是。
4. 优惠券提交订单就需要扣除。

#### OrderProductDto

OrderProductDto用来接收参数下单时商品的参数，这里只接受商品id和商品个数

```java
package com.jg.pochi.pojo.dto;

import lombok.Data;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/20 20:43
 * @Version 1.0
 */
@Data
public class OrderProductDto implements Serializable {

    /**
     * 商品ID
     */
    private Long productId;

    /**
     * 商品个数
     */
    private Integer count;

}

```

#### OrderDto

OrderDto用来接收订单参数，其中包装了OrderProductDto集合，即下单时允许多个商品

```java
package com.jg.pochi.pojo.dto;

import lombok.Data;

import java.io.Serializable;
import java.util.List;

/**
 * @Author: 杨德石
 * @Date: 2021/1/20 20:43
 * @Version 1.0
 */
@Data
public class OrderDto implements Serializable {

    /**
     * 商品列表
     */
    private List<OrderProductDto> productList;

    /**
     * 收货地址ID
     */
    private Long addressId;

    /**
     * 优惠券ID
     */
    private Long couponId;

    /**
     * 备注
     */
    private String note;

}

```

#### ShopOrder

```java
package com.jg.pochi.pojo;

import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;

/**
 * @Author: 杨德石
 * @Date: 2021/1/19 23:22
 * @Version 1.0
 */
@Data
public class ShopOrder implements Serializable {

    /**
     * 订单号
     */
    private Long id;
    /**
     * 创建人手机号
     */
    private String createBy;
    /**
     * 订单总金额
     */
    private BigDecimal totalAmount;
    /**
     * 应付金额
     */
    private BigDecimal payAmount;
    /**
     * 运费金额
     */
    private BigDecimal freightAmount;
    /**
     * 优惠券抵扣金额
     */
    private BigDecimal couponAmount;
    /**
     * 订单状态：0待付款；1待确认；2待发货；3已发货（待签收）；4已签收（待评价）；5已完成；6无效订单，7已关
     */
    private Integer status;
    /**
     * 订单类型，0正常订单，1秒杀订单
     */
    private Integer orderType;
    /**
     * 物流公司
     */
    private String deliveryCompany;
    /**
     * 物流单号
     */
    private String deliverySn;
    /**
     * 自动确认时间
     */
    private String autoConfirmDay;
    /**
     * 可获得的积分
     */
    private String integration;
    /**
     * 收货人姓名
     */
    private String receiverName;
    /**
     * 收货人电话
     */
    private String receiverPhone;
    /**
     * 收货人邮编
     */
    private String receiverPostCode;
    /**
     * 省份
     */
    private String receiverProvince;
    /**
     * 城市
     */
    private String receiverCity;
    /**
     * 区县
     */
    private String receiverRegion;
    /**
     * 详细地址
     */
    private String receiverDetailAddress;
    /**
     * 订单备注
     */
    private String note;
    /**
     * 确认收货状态，0未确认，1已确认
     */
    private Integer confirmStatus;
    /**
     * 支付时间
     */
    private String paymentTime;
    /**
     * 发货时间
     */
    private String deliveryTime;
    /**
     * 确认收货时间
     */
    private String receiveTime;
    /**
     * 评价时间
     */
    private String commentTime;
    /**
     * 是否评论，1是0否
     */
    private Integer isComment;
    /**
     * 创建时间
     */
    private String createTime;
    /**
     * 修改时间
     */
    private String updateTime;
    /**
     * 是否删除，1是0否
     */
    private Integer deleted;
}

```

#### ShopOrderItem

这里我们又遇到了冗余字段，相信大家学习到这里的时候已经不再疑问为什么这么设计了。用户购买商品以后，需要随时可以查看订单信息。这期间，商品可能下架、价格和积分可能修改、图片可能更换等等，而用户关注的仅仅是什么时候买了什么东西花了多少钱，这些参数一旦下单是不能变动的，因此这里我们记录了商品的一些基本信息作为冗余字段。

```java
package com.jg.pochi.pojo;

import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;

/**
 * @Author: 杨德石
 * @Date: 2021/1/19 23:41
 * @Version 1.0
 */
@Data
public class ShopOrderItem implements Serializable {

    /**
     * 主键
     */
    private Long id;

    /**
     * 订单编号
     */
    private Long orderId;

    /**
     * 商品编号
     */
    private Long productId;

    /**
     * 图片
     */
    private String productPic;

    /**
     * 商品名称
     */
    private String productName;

    /**
     * 品牌
     */
    private String productBrand;

    /**
     * 价格
     */
    private BigDecimal productPrice;

    /**
     * 购买数量
     */
    private Integer productQuantity;

    /**
     * 商品分类ID
     */
    private Long productCategoryId;

    /**
     * 积分
     */
    private Integer intergration;

    /**
     * 创建时间
     */
    private String createTime;

    /**
     * 修改时间
     */
    private String updateTime;

    /**
     * 是否删除，1是0否
     */
    private Integer deleted;

}

```

#### ShopOrderHistory

```java
package com.jg.pochi.pojo;

import lombok.Data;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/19 23:37
 * @Version 1.0
 */
@Data
public class ShopOrderHistory implements Serializable {

    /**
     * 主键
     */
    private Long id;

    /**
     * 订单ID
     */
    private Long orderId;

    /**
     * 操作人，用户、系统、管理员
     */
    private String operateMan;

    /**
     * 订单状态：0待付款；1待确认；2待发货；3已发货（待签收）；4已签收（待评价）；5已完成；6无效订单，7已关
     */
    private Integer orderStatus;

    /**
     * 备注
     */
    private String note;

    /**
     * 操作时间
     */
    private String createTime;

}

```

#### ShopOrderPay

```java
package com.jg.pochi.pojo;

import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;

/**
 * @Author: 杨德石
 * @Date: 2021/1/19 23:46
 * @Version 1.0
 */
@Data
public class ShopOrderPay implements Serializable {

    /**
     * 编号
     */
    private Long id;

    /**
     * 用户账号
     */
    private String createBy;

    /**
     * 微信访支付订单号
     */
    private String wxOrderNo;

    /**
     * 我方支付订单号
     */
    private String outTradeNo;

    /**
     * 订单号
     */
    private Long orderId;

    /**
     * 创建支付订单的参数，json字符串
     */
    private String orderParam;

    /**
     * 支付金额
     */
    private BigDecimal payAmount;

    /**
     * 创建时间
     */
    private String createTime;

    /**
     * 修改时间
     */
    private String updateTime;

    /**
     * 状态，0支付中，1支付成功，-1支付失败
     */
    private Integer status;

    /**
     * 是否删除，1是0否
     */
    private Integer deleted;

}

```



#### ShopOrderController

```java
    /**
     * 提交订单
     *
     * @param orderDto
     * @return
     */
    @RequestMapping(value = "/createOrder", method = RequestMethod.POST)
    public Result<?> createOrder(@RequestBody OrderDto orderDto) {
        shopOrderService.createOrder(orderDto);
        return new Result<>("订单提交成功");
    }
```

#### ShopOrderService

```java
    /**
     * 创建订单
     * @param orderDto
     */
    void createOrder(OrderDto orderDto);
```

#### ShopOrderServiceImpl

```java
package com.jg.pochi.service.impl;

import com.jg.pochi.enums.OperateEnum;
import com.jg.pochi.enums.OrderStateEnum;
import com.jg.pochi.mapper.ShopCouponMapper;
import com.jg.pochi.mapper.ShopOrderHistoryMapper;
import com.jg.pochi.mapper.ShopOrderItemMapper;
import com.jg.pochi.mapper.ShopOrderMapper;
import com.jg.pochi.mapper.ShopProductMapper;
import com.jg.pochi.mapper.ShopUserAddressMapper;
import com.jg.pochi.pojo.ShopCoupon;
import com.jg.pochi.pojo.ShopOrder;
import com.jg.pochi.pojo.ShopOrderHistory;
import com.jg.pochi.pojo.ShopOrderItem;
import com.jg.pochi.pojo.ShopProduct;
import com.jg.pochi.pojo.ShopUserAddress;
import com.jg.pochi.pojo.dto.OrderDto;
import com.jg.pochi.pojo.dto.OrderProductDto;
import com.jg.pochi.service.ShopOrderService;
import com.jg.pochi.shiro.LoginUser;
import com.jg.pochi.utils.IdWorker;
import com.jg.pochi.utils.ShiroUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @Author: 杨德石
 * @Date: 2021/1/19 23:37
 * @Version 1.0
 */
@Service
public class ShopOrderServiceImpl implements ShopOrderService {

    @Autowired
    private ShopProductMapper shopProductMapper;
    @Autowired
    private ShopCouponMapper shopCouponMapper;
    @Autowired
    private ShopUserAddressMapper shopUserAddressMapper;
    @Autowired
    private IdWorker idWorker;
    @Autowired
    private ShopOrderMapper shopOrderMapper;
    @Autowired
    private ShopOrderItemMapper shopOrderItemMapper;
    @Autowired
    private ShopOrderHistoryMapper shopOrderHistoryMapper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(OrderDto orderDto) {
        // 1. 前端提交订单参数：收货地址编号、商品编号、购买数量、优惠券编号等
        List<OrderProductDto> productDtoList = orderDto.getProductList();
        // 查询商品集合
        List<Long> productIds = productDtoList.stream().map(OrderProductDto::getProductId).collect(Collectors.toList());
        List<ShopProduct> productList = shopProductMapper.getByIds(productIds);
        Long couponId = orderDto.getCouponId();
        Long addressId = orderDto.getAddressId();
        // 查询地址
        ShopUserAddress address = shopUserAddressMapper.get(addressId);
        // 2. 商品扣减库存
        // 3. 计算总金额
        BigDecimal totalMoney = BigDecimal.ZERO;
        // 总积分
        BigDecimal totalPoint = BigDecimal.ZERO;
        for (ShopProduct product : productList) {
            OrderProductDto temp = productDtoList.stream().filter(d -> d.getProductId().equals(product.getId())).findFirst().orElse(null);
            product.setStock(product.getStock() - temp.getCount());
            // 计算该商品需要支付金额
            BigDecimal productMoney = product.getPrice().multiply(new BigDecimal(temp.getCount()));
            // 计算总金额
            totalMoney = totalMoney.add(productMoney);
            // 计算总积分
            BigDecimal point = product.getPoint();
            if (point != null) {
                totalPoint = totalPoint.add(point);
            }
        }
        // 应付金额
        BigDecimal payAmount = totalMoney;
        // 优惠券抵扣金额
        BigDecimal couponAmount = BigDecimal.ZERO;
        // 如果用了优惠券就扣除优惠券的金额
        if (couponId != null) {
            // 查询优惠券
            ShopCoupon shopCoupon = shopCouponMapper.get(couponId);
            if (shopCoupon != null) {
                couponAmount = shopCoupon.getAmount();
                payAmount = totalMoney.subtract(shopCoupon.getAmount());
            }
        }
        // 取出创建人
        LoginUser loginUser = ShiroUtils.getLoginUser();
        saveOrder(orderDto, productDtoList, productList, address, totalMoney, totalPoint, payAmount, couponAmount, loginUser);
        // TODO 5. 优惠券状态变更为已使用
    }

    /**
     * 保存订单
     *
     * @param orderDto       前端传递的参数
     * @param productDtoList 商品id和数量
     * @param productList    商品集合
     * @param address        地址
     * @param totalMoney     总金额
     * @param totalPoint     总积分
     * @param payAmount      应付金额
     * @param couponAmount   优惠券减免金额
     * @param loginUser      登录人
     */
    private void saveOrder(OrderDto orderDto, List<OrderProductDto> productDtoList, List<ShopProduct> productList, ShopUserAddress address, BigDecimal totalMoney, BigDecimal totalPoint, BigDecimal payAmount, BigDecimal couponAmount, LoginUser loginUser) {
        // 4. 存入订单表、订单项表、订单历史表
        ShopOrder order = new ShopOrder();
        order.setId(idWorker.nextId());
        order.setCreateBy(loginUser.getUsername());
        order.setTotalAmount(totalMoney);
        order.setPayAmount(payAmount);
        order.setCouponAmount(couponAmount);
        order.setDeliveryCompany("稽哥快递");
        order.setDeliverySn(idWorker.nextId() + "");
        order.setIntegration(totalPoint.toString());
        order.setReceiverName(address.getName());
        order.setReceiverPhone(address.getPhoneNumber());
        order.setReceiverPostCode("233333");
        order.setReceiverProvince(address.getProvince());
        order.setReceiverCity(address.getCity());
        order.setReceiverRegion(address.getRegion());
        order.setReceiverDetailAddress(address.getDetailAddress());
        order.setNote(orderDto.getNote());

        ShopOrderHistory orderHistory = new ShopOrderHistory();
        orderHistory.setId(idWorker.nextId());
        orderHistory.setOrderId(order.getId());
        orderHistory.setOperateMan(OperateEnum.USER.getType());
        orderHistory.setOrderStatus(OrderStateEnum.WAIT_PAY.getCode());
        // 构造订单项
        List<ShopOrderItem> shopOrderItemList = productList.stream().map(p -> {
            ShopOrderItem item = new ShopOrderItem();
            item.setId(idWorker.nextId());
            item.setOrderId(order.getId());
            item.setProductId(p.getId());
            item.setProductPic(p.getPic());
            item.setProductBrand(p.getBrandName());
            item.setProductPrice(p.getPrice());
            OrderProductDto temp = productDtoList.stream().filter(d -> d.getProductId().equals(p.getId())).findFirst().orElse(null);
            item.setProductQuantity(temp.getCount());
            item.setProductCategoryId(p.getCategoryId());
            item.setIntergration(p.getPoint().intValue());
            return item;
        }).collect(Collectors.toList());
        // 订单、订单项、订单历史入库，商品库存扣减
        shopOrderMapper.save(order);
        shopOrderHistoryMapper.save(orderHistory);
        shopOrderItemMapper.saveBatch(shopOrderItemList);
        for (ShopProduct product : productList) {
            shopProductMapper.updateStock(product);
        }
    }
}

```

#### ShopProductMapper

```java
    /**
     * 扣减库存
     * @param product
     */
    void updateStock(ShopProduct product);
```

#### ShopProductMapper.xml

```xml
    <update id="updateStock">
        update shop_product
        set stock = #{stock}
        where id = #{id}
    </update>
```

#### ShopCouponMapper

```java
    /**
     * 查询优惠券
     * @param couponId
     * @return
     */
    ShopCoupon get(Long couponId);
```

#### ShopCouponMapper.xml

```xml
    <select id="get" resultMap="BaseResultMap">
        select id,
               coupon_type,
               name,
               amount,
               min_point,
               start_time,
               end_time,
               rest_count,
               publish_count,
               use_count,
               receive_count,
               status
        from shop_coupon
        where id = #{id}
    </select>
```

#### ShopOrderMapper

```java
    /**
     * 添加
     * @param order
     */
    void save(ShopOrder order);
```

#### ShopOrderMapper.xml

```xml
    <insert id="save">
        insert into shop_order(id, create_by, total_amount, pay_amount, freight_amount, coupon_amount,
                               delivery_company, delivery_sn, integration, receiver_name,
                               receiver_phone, receiver_post_code, receiver_province, receiver_city,
                               receiver_region, receiver_detail_address, note)
        values (#{id}, #{createBy}, #{totalAmount}, #{payAmount}, #{freightAmount}, #{couponAmount},
                #{deliveryCompany}, #{deliverySn}, #{intergration}, #{receiverName},
                #{receiverPhone}, #{receiverPostCode}, #{receiverProvince}, #{receiverCity},
                #{receiverRegion}, #{receiverDetailAddress}, #{note})
    </insert>
```

#### ShopOrderHistoryMapper

```java

    /**
     * 添加
     * @param orderHistory
     */
    void save(ShopOrderHistory orderHistory);
```

#### ShopOrderHistoryMapper.xml

```xml
    <insert id="save">
        insert into shop_order_history(id, order_id, operate_man, order_status, note)
        VALUES (#{id}, #{orderId}, #{operateMan}, #{orderStatus}, #{note})
    </insert>
```

#### ShopOrderItemMapper

```java
    /**
     * 批量保存
     * @param shopOrderItemList
     */
    void saveBatch(List<ShopOrderItem> shopOrderItemList);
```

#### ShopOrderItemMapper.xml

```xml
    <insert id="saveBatch">
        insert into shop_order_item(
        id, order_id, product_id, product_pic, product_name, product_brand, product_price,
        product_quantity, product_category_id, integration)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{item.id}, #{item.orderId}, #{item.productId}, #{item.productPic}, #{item.productName},
            #{item.productBrand}, #{item.productPrice}, #{item.productQuantity}, #{item.productCategoryId},
            #{item.intergration})
        </foreach>
    </insert>
```



### 3.1.2 前端

前端逻辑如下：

1. 点击立即购买，跳转到订单填写页面，将商品编号和购买数量传入
2. 在订单填写页面重新加载商品信息、默认收货地址、可用优惠券
3. 使用计算属性计算支付金额
4. 点击提交订单，调用接口
5. 接口调用成功，跳转到支付页

```vue
<template>
	<view class="page">
		<!-- 地址 -->
		<view class="address-data">
			<view v-if="address" class="address-list" @click="onSkip(1)">
				<view class="list">
					<text>{{address.province}}{{address.city}}{{address.region}}</text>
				</view>
				<view class="list">
					<text class="address">{{address.detailAddress}}</text>
				</view>
				<view class="list">
					<text>{{address.name}}</text>
					<text>{{address.phoneNumber}}</text>
				</view>
				<view class="list">
					<text class="tips">(如果快递不方便接收，您可以选择暂时寄存服务)</text>
				</view>
			</view>
			<view v-else class="address-list" @click="onSkip()">
				<view class="list">
					<text class="tips">(如果快递不方便接收，您可以选择暂时寄存服务)</text>
				</view>
			</view>
			<view class="bar">

			</view>
		</view>
		<!-- 商品 -->
		<view class="goods-data">
			<view class="goods-title">
				<text>商品信息</text>
			</view>
			<view class="goods-list">
				<view class="list" v-for="(item,index) in productList" :key="index">
					<view class="thumb">
						<image :src="item.pic" mode=""></image>
					</view>
					<view class="item">
						<view class="title">
							<text class="name one-omit">{{item.name}}</text>
						</view>
						<view class="price-number">
							<view class="price">
								<text class="min">￥</text>
								<text class="max">{{String(item.price).split('.')[0]}}</text>
								<text class="min">.{{String(item.price).split('.')[1]?String(item.price).split('.')[1]:'00'}}</text>
							</view>
							<view class="number">
								<text>x {{item.stock}}</text>
							</view>
						</view>
					</view>
				</view>
			</view>
			<view class="delivery">
				<div class="list">
					<view class="title">配送</view>
					<view class="content">
						<text>快递运输</text>
						<text class="iconfont icon-more"></text>
					</view>
				</div>
				<div class="list">
					<view class="title">运费险</view>
					<view class="content">
						<text>￥10.00</text>
						<text class="iconfont icon-check"></text>
					</view>
				</div>
				<div class="list">
					<view class="title">留言</view>
					<view class="content">
						<input v-model="note" type="text" placeholder="选填,建议先和商家沟通确认">
					</view>
				</div>
			</view>
		</view>
		<!-- 优惠 -->
		<view class="discounts-data">
			<view class="discounts">
				<div class="list" @click="$refs['InvoiceInfo'].show()">
					<view class="title">发票</view>
					<view class="content">
						<text>不开发票</text>
						<text class="iconfont icon-more"></text>
					</view>
				</div>
				<div class="list" @click="$refs['UseCoupon'].show()">
					<view class="title">优惠券</view>
					<view class="content">
						<text>无可用</text>
						<text class="iconfont icon-more"></text>
					</view>
				</div>
				<div class="list">
					<view class="title">积分</view>
					<view class="content">
						<text>共300，满1000可用</text>
						<!-- <text class="iconfont icon-more"></text> -->
					</view>
				</div>
			</view>
		</view>
		<!-- 订单金额 -->
		<view class="order-price">
			<view class="price-list">
				<view class="list">
					<view class="title">
						<text>商品金额</text>
					</view>
					<view class="price">
						<text>￥{{productAmount}}</text>
					</view>
				</view>
				<view class="list">
					<view class="title">
						<text>优惠券减免</text>
					</view>
					<view class="price">
						<text class="highlight">-￥0.00</text>
					</view>
				</view>
			</view>
		</view>
		<!-- 地址提示 -->
		<view class="address-tips" :style="scrollTop >= 100 ? '':'display:none'">
			<text>{{address.province}}{{address.city}}{{address.region}}{{address.detailAddress}}</text>
		</view>
		<!-- 底部合计提交 -->
		<view class="footer-submit">
			<view class="price">
				<text class="min">￥</text>
				<text class="max">{{String(totalAmount).split('.')[0]}}</text>
				<text class="min">.{{String(totalAmount).split('.')[1]?String(totalAmount).split('.')[1]:'00'}}</text>
			</view>
			<view class="submit" @click="onSubmit">
				<text>提交订单</text>
			</view>
		</view>
		<!-- 发票 -->
		<invoice-info ref="InvoiceInfo"></invoice-info>
		<!-- 优惠券 -->
		<use-coupon ref="UseCoupon"></use-coupon>
	</view>
</template>

<script>
	import InvoiceInfo from '../../components/InvoiceInfo/InvoiceInfo.vue';
	import UseCoupon from '../../components/UseCoupon/UseCoupon.vue'
	import productApi from '@/api/shop-product.js'
	import addressApi from '@/api/shop-user-address.js'
	import orderApi from '@/api/shop-order.js'
	export default {
		components: {
			// 发票
			InvoiceInfo,
			// 优惠券
			UseCoupon,
		},
		onLoad(param) {
			this.paramArr = JSON.parse(param.productArr)
			const tempAddress = param.address
			console.log(tempAddress)
			if (tempAddress) {
				this.address = JSON.parse(tempAddress)
			} else {
				this.getAddressList()
			}
			this.getProductByIds()
		},
		computed: {
			// 商品金额
			productAmount() {
				if (this.productList && this.productList[0]) {
					return this.productList.map(e => e.price)
				} else {
					return 0
				}
			},
			// 优惠券减免
			couponAmount() {
				return 0
			},
			// 总金额
			totalAmount() {
				return this.productAmount - this.couponAmount
			}
		},
		data() {
			return {
				// 上一个页面传递来的数组
				paramArr: [],
				// 商品列表
				productList: [],
				// 收货地址
				address: {},
				// 备注
				note: '',
				scrollTop: 0,
			};
		},
		onPageScroll(e) {
			this.scrollTop = e.scrollTop;
		},
		methods: {
			// 加载收货地址
			getAddressList() {
				addressApi.getUserAddress().then(res => {
					const addressArr = res.data
					if (addressArr && addressArr[0]) {
						this.address = addressArr[0]
					}
				})
			},
			// 根据id集合回显商品信息
			getProductByIds() {
				const productIds = []
				this.paramArr.forEach(e => {
					productIds.push(e.productId)
				})
				productApi.getByIds(productIds).then(res => {
					res.data.forEach(e => {
						const index = this.paramArr.findIndex(p => p.productId === e.id)
						e.stock = this.paramArr[index].count
					})
					this.productList = res.data
				})
			},
			/**
			 * 提交订单
			 */
			onSubmit() {
				const productList = this.productList.map(e=>{
					return {productId: e.id, count: e.stock}
				})
				// 构造参数
				const order = {
					productList: productList,
					addressId: this.address.id,
					note: this.note
				}
				orderApi.createOrder(order).then(res=>{
					uni.showToast({
						title:res.msg
					})
					setTimeout(()=>{
						uni.redirectTo({
							url: '/pages/CashierDesk/CashierDesk',
						})
					}, 300)
				})
				
			},
			/**
			 * 跳转点击
			 * @param {String} type 跳转类型
			 */
			onSkip(type) {
				uni.navigateTo({
					url: `/pages/AddressList/AddressList?type=${type}&productArr=${JSON.stringify(this.paramArr)}`,
				})
			}
		}
	}
</script>

<style scoped lang="scss">
	@import 'ConfirmOrder.scss';
</style>

```

## 3.2 支付

### 3.2.1 后端

1. 改造订单接口，返回订单号和订单金额
2. 前端调用支付接口，存入支付订单表
3. 调起微信支付下单接口
4. 返回支付订单数据

> 此外，还需要提供定时任务，定时更新支付时间超过30分钟的订单，并回退库存。（这个功能如果使用了消息队列，可以使用延时队列实现）
>
> 本课程这里就不进行实现了。

#### WeChatConfig

```java
package com.jg.pochi.config;

import com.jg.pochi.utils.Md5Utils;
import com.jg.pochi.utils.StringUtils;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * @Author: 杨德石
 * @Date: 2020/12/12 16:52
 * @Version 1.0
 */
@Data
@Component
@ConfigurationProperties(prefix = "wechat")
public class WeChatConfig {

    private String appId;

    private String appSecret;

    private String grantType;

    private String loginUrl;

    /**
     * 商户号
     */
    private String mchId;

    /**
     * 秘钥
     */
    private String mchSecret;

    /**
     * 支付回调地址
     */
    private String notifyUrl;

    private String orderUrl;

    /**
     * 根据code获取登录地址
     *
     * @param code
     * @return
     */
    public String getAuthUrl(String code) {
        return "https://api.weixin.qq.com/sns/jscode2session?appid=" + appId + "&secret=" + appSecret + "&js_code=" + code + "&grant_type=" + grantType;
    }

    /**
     * 签名
     *
     * @param param
     * @return
     */
    public String getSign(TreeMap<String, Object> param) {
        List<String> list = new ArrayList<>();
        for (Map.Entry<String, Object> entry : param.entrySet()) {
            if (entry.getValue() == null || "".equals(entry.getValue().toString())) {
                continue;
            }
            list.add(entry.getKey() + "=" + entry.getValue());
        }
        String stringA = StringUtils.join(list, "&");
        String signTemp = stringA + "&key=" + this.getMchSecret();
        String sign = Md5Utils.toMD5(signTemp).toUpperCase();
        System.out.println(sign);
        return sign;
    }

}

```

#### ShopOrderController

```java
    /**
     * 创建支付订单
     * @param order
     * @throws Exception
     * @return
     */
    @RequestMapping(value = "/createPayOrder", method = RequestMethod.POST)
    public Result<WxOrderVo> createPayOrder(@RequestBody ShopOrder order) throws Exception {
        WxOrderVo vo = shopOrderService.createPayOrder(order);
        return new Result<>(vo);
    }
```

#### ShopOrderService

```java
    /**
     * 创建支付订单
     * @param order
     * @return
     * @throws Exception
     */
    WxOrderVo createPayOrder(ShopOrder order) throws Exception;

```

#### ShopOrderServiceImpl

```java
    @Override
    @Transactional(rollbackFor = Exception.class)
    public WxOrderVo createPayOrder(ShopOrder order) throws Exception {
        LoginUser loginUser = ShiroUtils.getLoginUser();
        order = shopOrderMapper.getPayInfo(order);
        String outTradeNo = idWorker.nextId() + "";
        WxOrderDto wxOrderDto = new WxOrderDto();
        wxOrderDto.setAppId(weChatConfig.getAppId());
        wxOrderDto.setMchId(weChatConfig.getMchId());
        wxOrderDto.setNonceStr(idWorker.nextId() + "");
        wxOrderDto.setBody("下单");
        wxOrderDto.setOutTradeNo(outTradeNo);
        wxOrderDto.setTotalFee(order.getPayAmount().toString());
        wxOrderDto.setSpbillCreateIp(InetAddress.getLocalHost().getHostAddress());
        wxOrderDto.setNotifyUrl(weChatConfig.getNotifyUrl());
        wxOrderDto.setTradeType("JSAPI");
        wxOrderDto.setOpenId(loginUser.getOpenId());
        wxOrderDto.setSign(weChatConfig.getSign(JSON.parseObject(JSON.toJSONString(wxOrderDto), TreeMap.class)));

        // 入库
        ShopOrderPay orderPay = new ShopOrderPay();
        orderPay.setId(idWorker.nextId());
        orderPay.setCreateBy(loginUser.getUsername());
        orderPay.setOutTradeNo(outTradeNo);
        orderPay.setOrderId(order.getId());
        orderPay.setPayAmount(orderPay.getPayAmount());
        orderPay.setOrderParam(JSON.toJSONString(wxOrderDto));
        shopOrderPayMapper.save(orderPay);

        String xmlParam = getXmlParam(wxOrderDto);
        String body = HttpUtils.post(weChatConfig.getOrderUrl(), xmlParam).body();
        Map<String, String> orderMap = WXPayUtil.xmlToMap(body);
        return buildOrder(orderMap.get("prepay_id"), wxOrderDto);
    }
```

#### ShopOrderPayMapper

```java
    /**
     * 保存
     * @param orderPay
     */
    void save(ShopOrderPay orderPay);
```

#### ShopOrderPayMapper.xml

```xml
    <insert id="save">
        insert into shop_order_pay(id, create_by, wx_order_no, out_trade_no, order_id, order_param, pay_amount)
        values (#{id}, #{createBy}, #{wxOrderNo}, #{outTradeNo}, #{orderId}, #{orderParam}, #{payAmount})
    </insert>
```



### 3.2.2 前端

前端逻辑如下

1. 点击提交订单，调用提交接口，页面跳转到支付页面
2. 点击支付按钮，调用支付接口进行支付
3. 跳转到支付成功页面

```vue
<template>
	<view class="page">
		<view class="price-count-down">
			<view class="price">
				<text class="min">￥</text>
				<text class="max">{{String(payAmount).split('.')[0]}}</text>
				<text class="min">.{{String(payAmount).split('.')[1]?String(payAmount).split('.')[1]:'00'}}</text>
			</view>
			<!-- <view class="count-down">
				<view class="title">支付剩余时间</view>
				<view class="count">
					<text class="time">{{hour}}</text>
					<text class="dot">:</text>
					<text class="time">{{min}}</text>
					<text class="dot">:</text>
					<text class="time">{{sec}}</text>
				</view>
			</view> -->
		</view> 
		<!-- 支付方式列表 -->
		<view class="pay-way">
			<view class="pay-list">
				<view class="list" v-for="(item,index) in PayList" 
				@click="onPayWay(item,index)"
				:key="index">
					<view class="pay-type">
						<image :src="item.icon" mode=""></image>
						<text>{{item.name}}</text>
					</view>
					<view class="check">
						<text class="iconfont" :class="PayWay === index ? 'icon-checked action':'icon-check'"></text>
					</view>
				</view>
			</view>
		</view>
		<view class="pay-submit">
			<view class="submit" @click="onSubmit">微信支付￥{{payAmount}}</view>
		</view>
	</view>
</template>

<script>
	import orderApi from '@/api/shop-order.js'
	export default {
		data() {
			return {
				PayList: [
					{
						icon: '/static/wx_pay.png',
						name: '微信支付',
					}
				],
				// 订单金额
				payAmount: null,
				// 订单号
				orderId: null,
				PayWay: 0,
				PayPirce: `微信支付￥299.00`,
				CountDown: 1000,
				day: 0,
				hour: 0,
				min: 0,
				sec: 0,
			};
		},
		onLoad(param){
			// 取出订单号和金额
			this.orderId = param.id
			this.payAmount = param.amount
			// this.CountDownData();
		},
		methods:{
			/**
			 * 支付方式切换点击
			 */
			onPayWay(item,index){
				this.PayWay = index;
				this.PayPirce = `${item.name}￥299.00`
			},
			/**
			 * 倒计时
			 */
			CountDownData(){
				setTimeout(() =>{
					this.CountDown--;
					this.day = parseInt(this.CountDown / (24*60*60))
					this.hour = parseInt(this.CountDown / (60 * 60) % 24);
					this.min = parseInt(this.CountDown / 60 % 60);
					this.sec = parseInt(this.CountDown % 60);
					if(this.CountDown <= 0){
						return
					}
					this.CountDownData();
				},1000)
			},
			/**
			 * 支付点击
			 */
			onSubmit(){
				// 调用支付接口
				orderApi.createPayOrder({id: this.orderId}).then(res=>{
					console.log(res)
					uni.requestPayment({
						...res.data,
						complete: (res) => {
							uni.redirectTo({
								url: `/pages/PayResult/PayResult?amount=${this.payAmount}`,
							})
						}
					})
				})
			}
		}
	}
</script>

<style scoped lang="scss">
	@import 'CashierDesk.scss';
</style>

```



## 3.3 支付成功

支付成功后，还需要做一些处理

### 3.3.1 后端（回调）

后端逻辑如下

1. 修改商品订单、订单项状态
2. 添加订单历史状态
3. 用户积分增加
4. 用户统计信息增加
5. 支付订单状态变更

#### NotifyController

```java
package com.jg.pochi.controller;

import com.alibaba.fastjson.JSON;
import com.github.wxpay.sdk.WXPayUtil;
import com.jg.pochi.config.WeChatConfig;
import com.jg.pochi.pojo.wx.PayNotifyDto;
import com.jg.pochi.pojo.wx.PayResultVo;
import com.jg.pochi.service.ShopOrderService;
import com.jg.pochi.utils.Md5Utils;
import com.jg.pochi.utils.StringUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * @Author: 杨德石
 * @Date: 2021/1/19 21:42
 * @Version 1.0
 */
@RestController
@RequestMapping("/notify")
@Slf4j
public class NotifyController {

    @Autowired
    private WeChatConfig weChatConfig;
    @Autowired
    private ShopOrderService shopOrderService;

    /**
     * 支付回调
     *
     * @param request
     * @return
     */
    @RequestMapping(value = "/payNotify")
    public String payNotify(HttpServletRequest request) {
        InputStream in = null;
        try {
            in = request.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            StringBuilder sb = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line).append("\n");
            }
            log.info("接收到微信支付回调：{}", sb.toString());
            System.out.println(sb.toString());
            Map<String, String> data = WXPayUtil.xmlToMap(sb.toString());
            PayNotifyDto payNotifyDto = JSON.parseObject(JSON.toJSONString(data), PayNotifyDto.class);
            data.remove("sign");
            String sign = getSign(new TreeMap<>(data));
            if (payNotifyDto.getSign().equals(sign)) {
                log.info("微信支付回调验签通过！");
                shopOrderService.handleOrderNotify(payNotifyDto);
            } else {
                log.info("验签失败！订单号：{}", payNotifyDto.getOutTradeNo());
            }
            return getSuccessResult();
        } catch (Exception e) {
            e.printStackTrace();
            log.error("微信回调操作失败：", e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return getFailResult();
    }

    private String getSuccessResult() {
        PayResultVo success = new PayResultVo("SUCCESS");
        try {
            return WXPayUtil.mapToXml(JSON.parseObject(JSON.toJSONString(success), Map.class));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private String getFailResult() {
        PayResultVo success = new PayResultVo("FAIL");
        try {
            return WXPayUtil.mapToXml(JSON.parseObject(JSON.toJSONString(success), Map.class));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 签名
     *
     * @param param
     * @return
     */
    private String getSign(TreeMap<String, Object> param) {
        List<String> list = new ArrayList<>();
        for (Map.Entry<String, Object> entry : param.entrySet()) {
            if (entry.getValue() == null || "".equals(entry.getValue().toString())) {
                continue;
            }
            list.add(entry.getKey() + "=" + entry.getValue());
        }
        String stringA = StringUtils.join(list, "&");
        String signTemp = stringA + "&key=" + weChatConfig.getMchSecret();
        String sign = Md5Utils.toMD5(signTemp).toUpperCase();
        System.out.println(sign);
        return sign;
    }
}

```

#### ShopOrderService

```java
    /**
     * 处理订单支付回调
     * @param payNotifyDto
     */
    void handleOrderNotify(PayNotifyDto payNotifyDto);
```

#### ShopOrderServiceImpl

```java
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void handleOrderNotify(PayNotifyDto payNotifyDto) {
        // 查询支付订单
        ShopOrderPay shopOrderPay = shopOrderPayMapper.getByOutTradeNo(payNotifyDto.getOutTradeNo());
        log.info("查询支付订单，支付订单号为：{}，订单详情：{}", payNotifyDto.getOutTradeNo(), JSON.toJSONString(shopOrderPay));
        // 查询商品订单
        ShopOrder order = shopOrderMapper.get(shopOrderPay.getOrderId());
        log.info("查询商品订单，订单号为：{}，订单详情：{}", shopOrderPay.getOrderId(), JSON.toJSONString(order));
        // 1. 修改商品订单
        order.setStatus(OrderStateEnum.WAIT_SEND.getCode());
        shopOrderMapper.updateOrderStatus(order);
        // 2. 添加订单历史状态
        ShopOrderHistory orderHistory = new ShopOrderHistory();
        orderHistory.setId(idWorker.nextId());
        orderHistory.setOrderId(order.getId());
        orderHistory.setOperateMan(OperateEnum.SYSTEM.getType());
        orderHistory.setOrderStatus(OrderStateEnum.WAIT_SEND.getCode());
        shopOrderHistoryMapper.save(orderHistory);
        // 3. 用户积分增加
        String integration = order.getIntegration();
        String username = order.getCreateBy();
        ShopUser user = shopUserMapper.getByPhone(username);
        if (StringUtils.isNotBlank(integration)) {
            BigDecimal point = new BigDecimal(integration);
            user.setPoint(user.getPoint().add(point));
            shopUserMapper.updatePoint(user);
        }
        // 4. 用户统计信息增加
        ShopUserStatistic shopUserStatistic = shopUserStatisticMapper.getByUserId(user.getId());
        shopUserStatistic.setOrderCount(shopUserStatistic.getOrderCount() + 1);
        shopUserStatistic.setConsumeAmount(shopUserStatistic.getConsumeAmount().add(order.getPayAmount()));
        if (order.getCouponAmount() != null && order.getCouponAmount().compareTo(BigDecimal.ZERO) > 0) {
            shopUserStatistic.setCouponCount(shopUserStatistic.getCommentCount() - 1);
        }
        shopUserStatisticMapper.update(shopUserStatistic);
        // 5. 支付订单状态变更
        shopOrderPay.setStatus(OrderStateEnum.PAY_SUCCESS.getCode());
        shopOrderPayMapper.updateStatus(shopOrderPay);
    }
```

#### ShopOrderPayMapper

```java
    /**
     * 根据订单号查询支付订单
     * @param outTradeNo
     * @return
     */
    ShopOrderPay getByOutTradeNo(String outTradeNo);


    /**
     * 修改状态
     * @param shopOrderPay
     */
    void updateStatus(ShopOrderPay shopOrderPay);
```

#### ShopOrderPayMapper.xml

```xml
    <select id="getByOutTradeNo" resultMap="BaseResultMap">
        select id,
               create_by,
               wx_order_no,
               out_trade_no,
               order_id,
               order_param,
               pay_amount,
               create_time,
               status,
               update_time
        from shop_order_pay
        where out_trade_no = #{outTradeNo}
    </select>
    <update id="updateStatus">
        update shop_order_pay
        set status = #{status}
        where id = #{id}
    </update>
```

#### ShopOrderMapper

```java
    /**
     * 根据id查询
     * @param orderId
     * @return
     */
    ShopOrder get(Long orderId);

    /**
     * 修改订单状态
     * @param order
     */
    void updateOrderStatus(ShopOrder order);
```

#### ShopOrderMapper.xml

```xml
    <select id="get" resultMap="BaseResultMap">
        select id,
               create_by,
               total_amount,
               pay_amount,
               freight_amount,
               coupon_amount,
               status,
               order_type,
               delivery_company,
               delivery_sn,
               auto_confirm_day,
               integration,
               receiver_name,
               receiver_phone,
               receiver_post_code,
               receiver_province,
               receiver_city,
               receiver_region,
               receiver_detail_address,
               note,
               confirm_status,
               payment_time,
               delivery_time,
               receive_time,
               comment_time,
               is_comment,
               create_time,
               update_time
        from shop_order
        where id = #{id}
    </select>

    <update id="updateOrderStatus">
        update shop_order
        set status = #{status}
        where id = #{id}
    </update>
```



# 4. 微信通知

小程序平台的类似概念叫做`模板消息`。

以微信为例，开发者的服务器发送消息给微信的服务器，微信服务器会发送一条模板消息，折叠到微信的消息列表中的服务通知里。它属于后台开发，和手机端无关。

[接口文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/template-message.html)

## 4.1 获取模板ID

在微信公众平台手动配置获取模板 ID：

登录 https://mp.weixin.qq.com 获取模板，如果没有合适的模板，可以申请添加新模板，审核通过后可使用。

![image-20201101224805993](https://ydsmarkdown.oss-cn-beijing.aliyuncs.com/md/20201101224806.png)

![image-20201102002625939](https://ydsmarkdown.oss-cn-beijing.aliyuncs.com/md/20201102002626.png)

![image-20201102002807275](https://ydsmarkdown.oss-cn-beijing.aliyuncs.com/md/20201102002807.png)



## 4.2 消息推送

### 获取AccessToken

推送消息之前需要获取AccessToken。实际上后端的大多数接口都需要获取AccessToken。

AccessToken请求之后需要保存到本地，如redis中。之后每次请求都从redis中获取即可。**极不建议每次请求都调用接口去获取，因为这样会导致并发情况下先获取的AccessToken失效**

#### 接口地址

```http
GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET
```

**请求参数**

| 属性       | 类型   | 默认值 | 必填 | 说明                                                         |
| ---------- | ------ | ------ | ---- | ------------------------------------------------------------ |
| grant_type | string |        | 是   | 填写 client_credential                                       |
| appid      | string |        | 是   | 小程序唯一凭证，即 AppID，可在「[微信公众平台](https://mp.weixin.qq.com) - 设置 - 开发设置」页中获得。（需要已经成为开发者，且帐号没有异常状态） |
| secret     | string |        | 是   | 小程序唯一凭证密钥，即 AppSecret，获取方式同 appid           |

**返回值**

| 属性         | 类型   | 说明                                           |
| ------------ | ------ | ---------------------------------------------- |
| access_token | string | 获取到的凭证                                   |
| expires_in   | number | 凭证有效时间，单位：秒。目前是7200秒之内的值。 |
| errcode      | number | 错误码                                         |
| errmsg       | string | 错误信息                                       |

#### application.yml

接下来我们在后台配置一下这个接口地址。

```yaml
wechat:
  appId: wx5068417ed65c6f6a
  appSecret: 
  loginUrl: https://api.weixin.qq.com/sns/jscode2session?grant_type=authorization_code&
  accessTokenUrl: https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&

```

#### WeChatConfig

```java
package com.jg.pochi.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * @Author: 杨德石
 * @Date: 2020/10/17 20:59
 * @Version 1.0
 */
@Data
@Component
@ConfigurationProperties(prefix = "wechat")
public class WeChatConfig {

    private String appId;
    private String appSecret;
    private String loginUrl;
    private String accessTokenUrl;

    public String getAuthUrl(String code) {
        // https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code
        return loginUrl + "appid=" + appId + "&secret=" + appSecret + "&js_code=" + code;
    }

    public String resolveAccessTokenUrl() {
        return accessTokenUrl + "appid=" + appId + "&secret=" + appSecret;
    }

}

```

#### WeChatAccessTokenResult

```java
/**
 * @Author: 杨德石
 * @Date: 2020/11/2 0:56
 * @Version 1.0
 */
@Data
public class WeChatAccessTokenResult {

    @JSONField(name = "access_token")
    private String accessToken;
    @JSONField(name = "expires_in")
    private String expiresIn;
    @JSONField(name = "errcode")
    private String errCode;
    @JSONField(name = "errmsg")
    private String errMsg;

}

```



#### WeChatService

现在，我们的微信相关接口已经有两个以上了，因此我们需要单独提供一下Service。之前的微信登录代码最好也搬过来。

```java
/**
 * @Author: 杨德石
 * @Date: 2020/11/2 0:54
 * @Version 1.0
 */
public interface WeChatService {

    WeChatAccessTokenResult getAccessToken();

}

```

#### WeChatServiceImpl

```java
package com.jg.pochi.service.impl;

import com.alibaba.fastjson.JSON;
import com.jg.pochi.config.WeChatConfig;
import com.jg.pochi.constant.CoreConstant;
import com.jg.pochi.pojo.vo.WeChatAccessToken;
import com.jg.pochi.service.WxService;
import com.jg.pochi.utils.HttpUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.io.IOException;

/**
 * @Author: 杨德石
 * @Date: 2021/1/21 21:54
 * @Version 1.0
 */
@Service
public class WxServiceImpl implements WxService {

    @Autowired
    private WeChatConfig weChatConfig;
    @Resource
    private RedisTemplate<String, String> redisTemplate;

    @Override
    public WeChatAccessToken getAccessToken() {
        // 先从redis里查询
        Long expire = redisTemplate.boundValueOps(CoreConstant.ACCESS_TOKEN_KEY).getExpire();
        if (expire == null || expire < 0) {
            // redis中不存在，需要获取
            try {
                String body = HttpUtils.get(weChatConfig.resolveAccessTokenUrl()).body();
                // 拿到了token字符串
                WeChatAccessToken token = JSON.parseObject(body, WeChatAccessToken.class);
                redisTemplate.boundValueOps(CoreConstant.ACCESS_TOKEN_KEY).set(body);
                return token;
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            String token = redisTemplate.boundValueOps(CoreConstant.ACCESS_TOKEN_KEY).get();
            return JSON.parseObject(token, WeChatAccessToken.class);
        }
        return null;
    }
}

```

#### 实现redis锁

事实上这里是有问题的。**redis单条命令是原子性，而多条命令之间是不具备原子性操作的。这就意味着在get和set操作之间，还会存在其他场景**。因此我们需要在这里上锁，最简单的就是使用 `synchronized` 关键字。但是该关键字是**重量级锁**，性能上并不是很好，而且分布式环境下并没有多大用途（~~虽然我们这里并不是分布式系统~~）。这里我们就可以使用redis锁。

redis锁的原理主要是使用 `setnx` 命令，redisTemplate中对应的是 `setIfAbsent` 方法。当使用该命令去set一个值时，如果不存在就set成功并返回1，否则set失败并返回0，这个过程是原子性的。

项目下新建 `lock` 包，包中创建 `RedisLock` 和 `RedisLockImpl` 两个类

##### RedisLock

```java
package com.jg.pochi.lock;

import java.util.concurrent.TimeUnit;

/**
 * @Author: 杨德石
 * @Date: 2021/1/21 22:21
 * @Version 1.0
 */
public interface RedisLock {

    /**
     * 上锁，默认超时时间5秒
     *
     * @param key
     * @return
     */
    boolean lock(String key);

    /**
     * 解锁
     *
     * @param key
     */
    void unlock(String key);

    /**
     * 上锁，指定超时时间，单位毫秒
     *
     * @param key
     * @param timeout
     * @return
     */
    boolean lock(String key, long timeout);

    /**
     * 上锁，指定超时时间和单位
     *
     * @param key
     * @param timeout
     * @param timeUnit
     * @return
     */
    boolean lock(String key, long timeout, TimeUnit timeUnit);

    /**
     * 尝试获取锁
     * @param lockKey 锁key
     * @param watTime 等待时间，在等待之间之内会一直尝试获取锁
     * @param leaseTime 锁失效时间
     * @return
     */
    boolean tryLock(String lockKey, long watTime, long leaseTime);
}

```

##### RedisLockImpl

```java
package com.jg.pochi.lock;

import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.concurrent.TimeUnit;

/**
 * @Author: 杨德石
 * @Date: 2021/1/21 22:24
 * @Version 1.0
 */
@Component
public class RedisLockImpl implements RedisLock {
    @Resource
    private RedisTemplate<String, String> redisTemplate;

    private static final long DEFAULT_TIMEOUT = 5000L;

    @Override
    public boolean lock(String key) {
        return lock(key, DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
    }

    @Override
    public void unlock(String key) {
        redisTemplate.delete(key);
    }

    @Override
    public boolean lock(String key, long timeout) {
        return lock(key, timeout, TimeUnit.MILLISECONDS);
    }

    @Override
    public boolean lock(String key, long timeout, TimeUnit timeUnit) {
        return redisTemplate.boundValueOps(key).setIfAbsent(key, timeout, timeUnit);
    }

    @Override
    public boolean tryLock(String lockKey, long watTime, long leaseTime) {
        long now = System.currentTimeMillis();
        while (System.currentTimeMillis() - now < watTime) {
            boolean flag = lock(lockKey, leaseTime, TimeUnit.MILLISECONDS);
            if(flag) {
                return flag;
            }
        }
        return false;
    }
}

```

##### 测试

```java
    @Test
    public void testLock() throws InterruptedException {
        for (int i = 0; i < 3; i++) {
            Thread t1 = new Thread(()->{
                boolean lock = redisLock.lock("lock");
                System.out.println(lock);
            });
            Thread t2 = new Thread(()->{
                boolean lock = redisLock.lock("lock");
                System.out.println(lock);
            });
            Thread t3 = new Thread(()->{
                boolean lock = redisLock.lock("lock");
                System.out.println(lock);
            });
            Thread t4 = new Thread(()->{
                boolean lock = redisLock.lock("lock");
                System.out.println(lock);
            });
            Thread t5 = new Thread(()->{
                boolean lock = redisLock.lock("lock");
                System.out.println(lock);
            });
            t1.start();
            t2.start();
            t3.start();
            t4.start();
            t5.start();
            Thread.sleep(5000);
        }
    }
```



> 我们这里的redis锁只实现了基本的原子性操作，而互斥性、可重入性功能并未实现。实际业务场景的分布式锁比这里的实现更优雅、更有扩展性、也更合理。本课程中因为要使用到分布式锁，但是不会专门去细讲（~~可能以后会有专门的课程去讲分布式锁。吧。~~），因此只是做一个简单的实现方案。感兴趣的同学也可以去了解一下 `lua` 脚本，或者 `redisson` 框架。前者可以使redis的多条命令原子性的操作，后者则是已经实现好的分布式锁。

##### WeChatServiceImpl

```java
    @Override
    public WeChatAccessToken getAccessToken() {
        // 先从redis里查询
        boolean lock = redisLock.tryLock(CoreConstant.ACCESS_TOKEN_KEY + "lock", 5000L, 5000L);
        if (lock) {
            Long expire = redisTemplate.boundValueOps(CoreConstant.ACCESS_TOKEN_KEY).getExpire();
            if (expire == null || expire < 0) {
                // redis中不存在，需要获取
                try {
                    String body = HttpUtils.get(weChatConfig.resolveAccessTokenUrl()).body();
                    // 拿到了token字符串
                    WeChatAccessToken token = JSON.parseObject(body, WeChatAccessToken.class);
                    redisTemplate.boundValueOps(CoreConstant.ACCESS_TOKEN_KEY).set(body, Integer.parseInt(token.getExpiresIn()) / 2, TimeUnit.MINUTES);
                    return token;
                } catch (IOException e) {
                    e.printStackTrace();
                }
            } else {
                String token = redisTemplate.boundValueOps(CoreConstant.ACCESS_TOKEN_KEY).get();
                return JSON.parseObject(token, WeChatAccessToken.class);
            }
        } else {
            throw new PochiException("获取AccessToken失败");
        }
        return null;
    }
```



### 消息推送接口

详见服务端消息发送接口 [subscribeMessage.send](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html)

#### 接口地址

```http
POST https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=ACCESS_TOKEN
```

其余参数使用 `JSON` 格式进行传输

| 属性              | 类型   | 默认值 | 必填 | 说明                                                         |
| ----------------- | ------ | ------ | ---- | ------------------------------------------------------------ |
| access_token      | string |        | 是   | [接口调用凭证](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html) |
| touser            | string |        | 是   | 接收者（用户）的 openid                                      |
| template_id       | string |        | 是   | 所需下发的订阅模板id                                         |
| page              | string |        | 否   | 点击模板卡片后的跳转页面，仅限本小程序内的页面。支持带参数,（示例index?foo=bar）。该字段不填则模板无跳转。 |
| data              | Object |        | 是   | 模板内容，格式形如 { "key1": { "value": any }, "key2": { "value": any } } |
| miniprogram_state | string |        | 否   | 跳转小程序类型：developer为开发版；trial为体验版；formal为正式版；默认为正式版 |
| lang              | string |        | 否   | 进入小程序查看”的语言类型，支持zh_CN(简体中文)、en_US(英文)、zh_HK(繁体中文)、zh_TW(繁体中文)，默认为zh_CN |

#### application.yml

```yaml
wechat:
  appId: wx5068417ed65c6f6a
  appSecret: 
  loginUrl: https://api.weixin.qq.com/sns/jscode2session?grant_type=authorization_code&
  accessTokenUrl: https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&
  pushUrl: https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=


```

#### PushDto

这里我们只传必传参数，非必传参数大家自行尝试。

```java
package com.jg.pochi.pojo.wx;

import com.alibaba.fastjson.annotation.JSONField;
import lombok.Data;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/21 23:04
 * @Version 1.0
 */
@Data
public class PushDto<T> implements Serializable {

    @JSONField(name = "access_token")
    private String accessToken;

    private String touser;

    @JSONField(name = "template_id")
    private String templateId;

    private T data;

}

```

#### OrderTemplate

OrderTemplate用来构造微信模板的参数，这里需要使用到 `TemplateValue` 类，该类只有一个value属性，较为简单就不写到这里了。

```java
package com.jg.pochi.pojo.wx;

import com.alibaba.fastjson.annotation.JSONField;
import lombok.Data;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/21 23:06
 * @Version 1.0
 */
@Data
public class OrderTemplateDto implements Serializable {

    @JSONField(name = "character_string1")
    private TemplateValue orderId;

    @JSONField(name = "date2")
    private TemplateValue orderTime;

    @JSONField(name = "thing3")
    private TemplateValue productName;

    @JSONField(name = "amount4")
    private TemplateValue amount;

    @JSONField(name = "thing7")
    private TemplateValue address;

}

```



#### WeChatConfig

```java
    public String getPushUrl(String accessToken) {
        return pushUrl + accessToken;
    }
```

#### WeChatService

```java
    /**
     * 推送消息
     *
     * @param template
     * @param templateId
     */
    void pushMessage(OrderTemplateDto template, String templateId);

```



#### WeChatServiceImpl

```java
    @Override
    public void pushMessage(OrderTemplateDto template, String templateId) {
        PushDto<OrderTemplateDto> pushDto = new PushDto<>();
        pushDto.setAccessToken(getAccessToken().getAccessToken());
//        pushDto.setTouser(ShiroUtils.getLoginUser().getOpenId());
        pushDto.setTouser("o0OpY4zdWx85GGO8IHTsG6a8MBkw");
        pushDto.setData(template);
        pushDto.setTemplateId(templateId);
        try {
            String body = HttpUtils.post(weChatConfig.resolvePushUrl(pushDto.getAccessToken()), JSON.toJSONString(pushDto)).body();
            log.info("消息推送接口调用成功：{}", body);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

#### PushTest

这里我们先测一下接口通不通，直接发送消息看返回值

```java
    @Test
    public void testSendMessage() throws Exception {
        OrderTemplateDto template = new OrderTemplateDto();
        template.setAddress(new TemplateValue("安徽"));
        template.setAmount(new TemplateValue("1"));
        template.setOrderId(new TemplateValue("89123478912738912"));
        template.setOrderTime(new TemplateValue("2020-02-02 12:12:12"));
        template.setProductName(new TemplateValue("哈哈"));
        wxService.pushMessage(template, "mR8UIyXR7PAEvE9n-zJpPHVV5it3-5qtRECfSOfXvAQ");
    }
```

> 这里返回的结果如果是 `{"errcode":"43101","errmsg":"user refuse to accept the msg rid: 5fa01d5c-09c77dd0-3a9a4e17"}` ，就表示发送成功了，但是用户拒收了。

## 4.3 前端

前端要做的事情很简单，就是请求用户授权接收消息即可。

[接口地址](https://uniapp.dcloud.io/api/other/requestSubscribeMessage?id=requestsubscribemessage)

**uni.requestSubscribeMessage(Object object)**

**平台差异说明**

| App  |  H5  |    微信小程序     | 支付宝小程序 | 百度小程序 | 字节跳动小程序 | QQ小程序 |
| :--: | :--: | :---------------: | :----------: | :--------: | :------------: | :------: |
|  x   |  x   | 基础库版本>=2.8.2 |      x       |     x      |       x        |    x     |

**object参数说明**

|   属性   |   类型   | 默认值 | 必填 |                             说明                             |
| :------: | :------: | :----: | :--: | :----------------------------------------------------------: |
| tmplIds  |  Array   |        |  是  | 需要订阅的消息模板的id的集合，一次调用最多可订阅3条消息（注意：iOS客户端7.0.6版本、Android客户端7.0.7版本之后的一次性订阅/长期订阅才支持多个模板消息，iOS客户端7.0.5版本、Android客户端7.0.6版本之前的一次订阅只支持一个模板消息）消息模板id在[微信公众平台(mp.weixin.qq.com)-功能-订阅消息]中配置 |
| success  | function |        |  否  |                    接口调用成功的回调函数                    |
|   fail   | function |        |  否  |                    接口调用失败的回调函数                    |
| complete | function |        |  否  |       接口调用结束的回调函数（调用成功、失败都会执行）       |

我们需要在指定的地方去调用这个api，比如下单前，或者表单提交前。

### 页面

我们在 **我的** 页面任意一个按钮中绑定一下唤起订阅消息的页面进行测试。

```java
			requestMessage() {
				uni.requestSubscribeMessage({
					tmplIds: ['DEB2AGs-4NNR-Gjt2tCRkWazS6Rzr29YebKe9ZNB2Zg'],
					complete: (res)=>{
						console.log(res)
					}
				})
			},
```

![image-20201103005810425](https://ydsmarkdown.oss-cn-beijing.aliyuncs.com/md/20201103005810.png)



接下来我们尝试用后端的测试类发送一条消息，发送消息成功，。

![image-20201103010550798](https://ydsmarkdown.oss-cn-beijing.aliyuncs.com/md/20201103010550.png)

***

目前，微信已经废弃了**模板消息**功能，开发者无法主动推送消息给用户。订阅消息分为一次性订阅和永久订阅，永久订阅功能对行业有要求，大部分的小程序都无法使用，因此这里的**消息订阅必须每次发消息前都让用户去授权。**

这个用户体验确实很差，对小程序来说无疑是一次降维打击，但是很遗憾，**只靠小程序是无法解决这个难点的**

因此我们可以通过其他方式进行解决。这里推荐一种方案，也是目前使用较多的一种方案，就是**借助公众号的模板消息**功能完成消息推送。微信只废弃了小程序的模板消息，而公众号的仍然保留了。在小程序中，开发者可以引导用户去关注指定公众号，这样下单后通过公众号去推送消息即可。

公众号的申请也在微信公众平台，这里就不进行介绍了。

![image-20201103013403836](https://ydsmarkdown.oss-cn-beijing.aliyuncs.com/md/20201103013403.png)

## 4.4 下单推送

最后，我们在回调接口里，将消息推送代码编写进去

```java
// 通知用户支付成功
        OrderTemplateDto template = new OrderTemplateDto();
        template.setAddress(new TemplateValue(order.getReceiverProvince() + order.getReceiverCity() + order.getReceiverRegion() + order.getReceiverDetailAddress()));
        template.setAmount(new TemplateValue(order.getPayAmount().toString()));
        template.setOrderId(new TemplateValue(order.getId() + ""));
        template.setOrderTime(new TemplateValue(order.getCreateTime()));
        template.setProductName(new TemplateValue("宠物商品"));
        wxService.pushMessage(template, "mR8UIyXR7PAEvE9n-zJpPHVV5it3-5qtRECfSOfXvAQ", user.getOpenId());
    
```



# 5. 购物车下单

购物车下单并没有太大的难度，我们只需要让用户选取指定的商品，然后把商品ID集合和数量传递到下单页面即可，其余操作和下单一模一样。

## 后端

```java
        // 6. 如果购物车项ID不为空，清空购物车项
        Long cartId = productDtoList.get(0).getCartId();
        if (cartId != null) {
            // 说明是购物车下单，清空这些购物车项
            List<Long> cartIds = productDtoList.stream().map(OrderProductDto::getCartId).collect(Collectors.toList());
            shopCartItemMapper.deleteByIds(cartIds);
        }
```



## 前端

```vue
			// 去结算
			toPay() {
				const checkGoods = []
				this.goodsList.forEach(e=>{
					if(e.check) {
						checkGoods.push({cartId: e.id,productId: e.productId, count: e.quantity})
					}
				})
				if(checkGoods[0]) {
					uni.navigateTo({
						url: '/pages/ConfirmOrder/ConfirmOrder?productArr=' + JSON.stringify(checkGoods)
					})
				}
			},
```



# 6. 优惠券

## 6.1 购物券过期

购物券过期的功能并没有什么高性能的操作方式，就是提供一个 **定时任务**，每隔一段时间去更新一下有效时间截止在当前时间之前的优惠券。

本课程目前涉及到定时任务的地方不多，这里就使用 **SpringTask**。SpringBoot已经默认为我们集成了这个框架，只需要在启动类上开启即可。

### ShopCouponTask

创建 `ShopCouponTask` 类，内容如下。

```java
package com.jg.pochi.task;

import com.jg.pochi.service.ShopCouponService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * @Author: 杨德石
 * @Date: 2020/11/4 0:29
 * @Version 1.0
 */
@Component
public class ShopCouponTask {

    @Autowired
    private ShopCouponService shopCouponService;

    /**
     * 每分钟更新一次过期时间
     */
    @Scheduled(cron = "0 0/1 * * * ?")
    public void refreshCouponStatus() {
        shopCouponService.updateTimeOutCoupon();
    }

}

```

### ShopCouponService

```java
    /**
     * 更新过期优惠券
     */
    void updateTimeoutCoupon();
```



### ShopCouponServiceImpl

```java
    @Override
    public void updateTimeoutCoupon() {
        shopCouponMapper.updateTimeoutCoupon();
    }
```

### ShopCouponMapper

```java
    /**
     * 更新过期优惠券
     */
    void updateTimeoutCoupon();
```



### ShopCouponMapper.xml

```xml
    <update id="updateTimeoutCoupon">
        update shop_coupon
        set status = 0
        where end_time <![CDATA[<]]> now()
          and status = 1
    </update>
```

## 6.2 领取优惠券

用户在商品页可以领取自己的优惠券。领取优惠券的步骤如下。

1. 查询优惠券数据，校验剩余数量
2. 更新领取数量和剩余数量
3. 在 **优惠券历史表** 中插入一条领取记录，状态为 **未使用**
4. 在 **用户统计表** 中将优惠券数量+1

在领取优惠券开发完毕后，我们还需要再次开发获取优惠券的功能，**要将该用户已领取过的优惠券状态改为已领取**

### 6.2.1 后端

#### ShopCouponHistory

```java
package com.jg.pochi.pojo;

import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;

/**
 * @Author: 杨德石
 * @Date: 2021/1/22 21:51
 * @Version 1.0
 */
@Data
public class ShopCouponHistory implements Serializable {

    /**
     * 自增主键
     */
    private Long id;

    /**
     * 优惠券ID
     */
    private Long couponId;

    /**
     * 领取人账号
     */
    private String createBy;

    /**
     * 是用状态，0未使用，1已使用，2已过期
     */
    private Integer useStatus;

    /**
     * 使用时间
     */
    private String useTime;

    /**
     * 使用的订单ID
     */
    private Long orderId;

    /**
     * 面值
     */
    private BigDecimal amount;

    /**
     * 最少使用金额
     */
    private BigDecimal minPoint;

    /**
     * 创建时间
     */
    private String createTime;

}

```



#### ShopCouponController

```java
    /**
     * 领取优惠券
     * @param shopCoupon
     * @return
     */
    @RequestMapping(value = "/catchCoupon", method = RequestMethod.POST)
    public Result<?> catchCoupon(@RequestBody ShopCoupon shopCoupon) {
        shopCouponService.catchCoupon(shopCoupon);
        return new Result<>("领取成功");
    }
```

#### ShopCouponService

```java
    /**
     * 领取优惠券
     * @param shopCoupon
     */
    void catchCoupon(ShopCoupon shopCoupon);
```



#### ShopCouponServiceImpl

```java
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void catchCoupon(ShopCoupon shopCoupon) {
        LoginUser loginUser = ShiroUtils.getLoginUser();
        // 1. 查询优惠券数据，校验剩余数量
        ShopCoupon coupon = shopCouponMapper.get(shopCoupon.getId());
        if (coupon.getRestCount() <= 0) {
            throw new PochiException("优惠券已经领取完毕");
        }
        // 2. 更新领取数量和剩余数量
        coupon.setRestCount(coupon.getRestCount() - 1);
        coupon.setReceiveCount(coupon.getReceiveCount() + 1);
        shopCouponMapper.updateCount(coupon);
        // 3. 在优惠券历史表中插入一条领取记录，状态为未使用
        ShopCouponHistory shopCouponHistory = new ShopCouponHistory();
        shopCouponHistory.setCouponId(coupon.getId());
        shopCouponHistory.setCreateBy(loginUser.getUsername());
        shopCouponHistory.setAmount(coupon.getAmount());
        shopCouponHistory.setMinPoint(coupon.getMinPoint());
        shopCouponHistoryMapper.save(shopCouponHistory);
        // 4. 在用户统计表中将优惠券数量+1
        ShopUserStatistic statistic = shopUserStatisticMapper.getByUserId(loginUser.getId());
        statistic.setCouponCount(statistic.getCouponCount() + 1);
        shopUserStatisticMapper.update(statistic);
    }

    @Override
    public List<ShopCoupon> getProductCoupon(Long productId) {
        // 查询商品信息
        ShopProduct product = shopProductMapper.getInfoById(productId);
        // 查询全场通用优惠券
        List<ShopCoupon> bothList = shopCouponMapper.getBothCoupon();
        // 查询该商品所在分类的优惠券
        List<ShopCoupon> categoryCouponList = shopCouponMapper.getByCategoryId(product.getCategoryId());
        // 查询该商品的优惠券
        List<ShopCoupon> productCouponList = shopCouponMapper.getByProductId(productId);
        bothList.addAll(categoryCouponList);
        bothList.addAll(productCouponList);
        if (!CollectionUtils.isEmpty(bothList)) {
            // 根据优惠券id集合和用户账号查询优惠券领取历史，判断优惠券是否已经被领取
            List<Long> couponIds = bothList.stream().map(ShopCoupon::getId).collect(Collectors.toList());
            String username = ShiroUtils.getLoginUser().getUsername();
            List<ShopCouponHistory> historyList = shopCouponHistoryMapper.getByCouponIdsAndUsername(couponIds, username);
            if (!CollectionUtils.isEmpty(historyList)) {
                bothList.forEach(c -> {
                    ShopCouponHistory history = historyList.stream().filter(h -> h.getCouponId().equals(c.getId())).findFirst().orElse(null);
                    if (history != null) {
                        c.setStatus(StateEnums.COUPON_RECEIVE.getCode());
                    }
                });
            }
        }
        return bothList;
    }
```

#### ShopCouponMapper

```java
    /**
     * 更新数量
     * @param coupon
     */
    void updateCount(ShopCoupon coupon);
```



#### ShopCouponMapper.xml

```xml
    <update id="updateCount">
        update shop_coupon
        set rest_count    = #{restCount},
            receive_count = #{receiveCount},
            use_count     = #{useCount}
        where id = #{id}
    </update>
```



#### ShopCouponHistoryMapper

```java
    /**
     * 添加
     * @param shopCouponHistory
     */
    void save(ShopCouponHistory shopCouponHistory);

    /**
     * 根据优惠券ID集合和用户名查询
     *
     * @param couponIds
     * @param username
     * @return
     */
    List<ShopCouponHistory> getByCouponIdsAndUsername(@Param("list") List<Long> couponIds, @Param("username") String username);

```



#### ShopCouponHistoryMapper.xml

```xml
    <insert id="save">
        insert into shop_coupon_history(coupon_id, create_by, order_id, amount)
        values (#{couponId}, #{createBy}, #{orderId}, #{amount})
    </insert>

    <select id="getByCouponIdsAndUsername" resultMap="BaseResultMap">
        select *
        from shop_coupon_history
        where create_by = #{username}
        and coupon_id in (
        <foreach collection="list" item="id" separator=",">#{id}
        </foreach>
        )
    </select>
```

### 6.2.2 前端

我们在前端开发，一是要在领取完优惠券后刷新优惠券列表，二是要将已领取的优惠券状态变更为已领取。

```vue
<template>
		<view class="cu-modal bottom-modal" :class="{'show':isShow}" @click="hide">
		  <view class="cu-dialog">
		    <view class="modal-title">
					<text>优惠券</text>
				</view>
				<view class="tips">可领取优惠券</view>
				<view class="coupon-list">
					<view class="list" v-for="item in couponList" :key="item.id">
						<view class="coupon-price">
							<view class="discounts">
								<text class="min">￥</text>
								<text class="max">{{item.amount}}</text>
							</view>
							<view class="full-reduction">
								<text>满{{item.minPoint}}元减{{item.amount}}元</text>
							</view>
							<view class="jag"></view>
						</view>
						<view class="coupon-info">
							<view class="info-title">
								<view class="tag">
									<text v-if="item.couponType === 0">全场通用</text>
									<text v-else-if="item.couponType === 1">限品类券</text>
									<text v-else>限本商品</text>
								</view>
								<view class="title">
									<text>{{item.name}}</text>
								</view>
							</view>
							<view class="date-get">
								<view class="date">
									<text>{{String(item.startTime).split(' ')[0]}}-{{String(item.endTime).split(' ')[0]}}</text>
								</view>
								<view class="get" v-if="item.status === 1" @click="catchCoupon(item.id)">
									<text>点击领取</text>
								</view>
								<view class="get" v-else>
									<text>点击领取</text>
								</view>
							</view>
						</view>
						<view class="use-status" v-if="item.status === 0">
							<text>已过期</text>
						</view>
						<view class="use-status" v-if="item.status === 999">
							<text>已领取</text>
						</view>
					</view>
				</view>
		  </view>
		</view>
</template>

<script>
	import couponApi from '@/api/shop-coupon.js'
	export default {
		data() {
			return {
				isShow: false,
				isPage: false,
			}
		},
		props: {
			// 优惠券列表
			couponList: {
				type: Array,
				default() {
					return {}
				}
			}
		},
		methods: {
			// 领取优惠券
			catchCoupon(id) {
				couponApi.catchCoupon({id}).then(res=>{
					uni.showToast({
						title:res.msg
					})
					setTimeout(()=>{
						this.$emit('refreshCoupon')
					}, 300)
				})
			},
			show(){
				this.isPage = true;
				setTimeout(() =>{
					this.isShow = true;
				},300)
			},
			hide(){
				this.isShow = false;
				setTimeout(() =>{
					this.isPage = false;
				},300)
			},
		},
	}
</script>

<style scoped lang="scss">
	@import 'GoodsCoupon.scss';
</style>

```



## 6.3 优惠券支付

优惠券领取完毕后，在我们的订单页就需要加载可用优惠券了，处于简单考虑，这里我们只加载 **首个商品能够使用的优惠券**，而在真实的业务中，应当取交集，或者允许为每个商品单独使用优惠券，又或者是对不同分类、店铺的商品进行拆单操作，也可以加载出全部的优惠券，并标注哪些优惠券可以使用。

领取完优惠券之后，提交订单时就需要将优惠券ID也提交过去。

### 6.3.1 后端

```java
    @Override
    @Transactional(rollbackFor = Exception.class)
    public ShopOrder createOrder(OrderDto orderDto) {
        // 1. 前端提交订单参数：收货地址编号、商品编号、购买数量、优惠券编号等
        List<OrderProductDto> productDtoList = orderDto.getProductList();
        // 查询商品集合
        List<Long> productIds = productDtoList.stream().map(OrderProductDto::getProductId).collect(Collectors.toList());
        List<ShopProduct> productList = shopProductMapper.getByIds(productIds);
        Long couponId = orderDto.getCouponId();
        Long addressId = orderDto.getAddressId();
        // 查询地址
        ShopUserAddress address = shopUserAddressMapper.get(addressId);
        // 2. 商品扣减库存
        // 3. 计算总金额
        BigDecimal totalMoney = BigDecimal.ZERO;
        // 总积分
        BigDecimal totalPoint = BigDecimal.ZERO;
        for (ShopProduct product : productList) {
            OrderProductDto temp = productDtoList.stream().filter(d -> d.getProductId().equals(product.getId())).findFirst().orElse(null);
            product.setStock(product.getStock() - temp.getCount());
            // 计算该商品需要支付金额
            BigDecimal productMoney = product.getPrice().multiply(new BigDecimal(temp.getCount()));
            // 计算总金额
            totalMoney = totalMoney.add(productMoney);
            // 计算总积分
            BigDecimal point = product.getPoint();
            if (point != null) {
                totalPoint = totalPoint.add(point);
            }
        }
        // 应付金额
        BigDecimal payAmount = totalMoney;
        // 优惠券抵扣金额
        BigDecimal couponAmount = BigDecimal.ZERO;
        // 如果用了优惠券就扣除优惠券的金额
        if (couponId != null) {
            // 查询优惠券
            ShopCoupon shopCoupon = shopCouponMapper.get(couponId);
            if (shopCoupon != null) {
                couponAmount = shopCoupon.getAmount();
                payAmount = totalMoney.subtract(shopCoupon.getAmount());
            }
        }
        // 取出创建人
        LoginUser loginUser = ShiroUtils.getLoginUser();
        ShopOrder order = saveOrder(orderDto, productDtoList, productList, address, totalMoney, totalPoint, payAmount, couponAmount, loginUser);
        // 5. 优惠券状态变更为已使用
        if(orderDto.getCouponId() != null) {
            // 更新优惠券使用数量
            ShopCoupon coupon = shopCouponMapper.get(orderDto.getCouponId());
            coupon.setUseCount(coupon.getUseCount()+1);
            shopCouponMapper.updateCount(coupon);
            // 优惠券领取历史表数据状态变更为已使用，更新使用时间和订单号
            ShopCouponHistory shopCouponHistory  = shopCouponHistoryMapper.getByCouponIdAndUsername(coupon.getId(), loginUser.getUsername());
            shopCouponHistory.setUseStatus(StateEnums.COUPON_NORMAL.getCode());
            shopCouponHistory.setUseTime(DateUtils.newDateTime());
            shopCouponHistory.setOrderId(order.getId());
            shopCouponHistoryMapper.updateToUse(shopCouponHistory);
        }
        // 6. 如果购物车项ID不为空，清空购物车项
        Long cartId = productDtoList.get(0).getCartId();
        if (cartId != null) {
            // 说明是购物车下单，清空这些购物车项
            List<Long> cartIds = productDtoList.stream().map(OrderProductDto::getCartId).collect(Collectors.toList());
            shopCartItemMapper.deleteByIds(cartIds);
        }
        return order;
    }
```



### 6.3.2 前端

#### UseCoupon.vue

```vue
<template>
	<view class="page-total">
		<view class="cu-modal bottom-modal" :class="{ show: isShow }">
			<view class="cu-dialog">
				<view class="coupon-title">
					<view class="title">优惠券</view>
					<view class="explain">使用说明</view>
				</view>
				<view class="coupon-tab">
					<view class="tab" :class="{'action':TabShow===0}" @click.stop="onTab(0)">
						<text>可用优惠券（{{couponList.length}}）</text>
						<text class="line"></text>
					</view>
					<view class="tab" :class="{'action':TabShow===1}" @click.stop="onTab(1)">
						<text>不可用优惠券（1）</text>
						<text class="line"></text>
					</view>
				</view>
				<!-- 优惠券数据 -->
				<view class="coupon-data">
					<view class="coupon-list">
						<view class="list" :class="{'forbidden':TabShow === 1}" v-for="(item,index) in couponList" :key="index">
							<view class="coupon-price">
								<view class="discounts">
									<text class="min">￥</text>
									<text class="max">{{item.amount}}</text>
								</view>
								<view class="full-reduction">
									<text>满{{item.minPoint}}元减{{item.amount}}元</text>
								</view>
								<view class="jag"></view>
							</view>
							<view class="coupon-info">
								<view class="check" @click="changeCheck(item)" v-show="TabShow === 0">
									<view class="iconfont icon-checked" v-if="item.check"></view>
									<view class="iconfont icon-check" v-else></view>
								</view>
								<view class="info-title">
									<view class="tag">
										<text v-if="item.couponType === 0">全场通用</text>
										<text v-else-if="item.couponType === 1">限品类券</text>
										<text v-else>限本商品</text>
									</view>
									<view class="title">
										<text>{{item.name}}</text>
									</view>
								</view>
								<view class="date-get">
									<view class="date">
										<text>{{String(item.startTime).split(' ')[0]}}-{{String(item.endTime).split(' ')[0]}}</text>
									</view>
									<!-- <view class="get">
										<text>点击领取</text>
									</view> -->
								</view>
							</view>
						</view>
					</view>
				</view>
				<!--确认 -->
				<view class="cpupon-confirm">
					<view class="confirm" @click.stop="onConfirm">确定</view>
				</view>
			</view>
		</view>
	</view>
</template>

<script>
	export default {
		data() {
			return {
				isShow: false,
				TabShow: 0,
				// 当前选中的优惠券
				currentCoupon: null
			};
		},
		props: {
			// 优惠券列表
			couponList: {
				type: Array,
				default () {
					return {}
				}
			}
		},
		methods: {			// 选中
			changeCheck(item) {
				this.couponList.forEach(e=>{
					if(e.check) {
						this.$set(e, 'check', false)
					}
				})
				this.$set(item, 'check', true)
				this.currentCoupon = item
			},
			show() {
				this.isShow = true;
			},
			hide() {
				this.isShow = false;
			},
			/**
			 * tab 点击
			 */
			onTab(index) {
				this.TabShow = index;
			},
			/**
			 * 确认点击
			 */
			onConfirm() {
				this.hide();
				this.$emit('checkCoupon', this.currentCoupon)
			}
		}
	}
</script>

<style scoped lang="scss">
	@import 'UseCoupon.scss';
</style>

```

#### ConfirmOrder.vue

```vue
<template>
	<view class="page">
		<!-- 地址 -->
		<view class="address-data">
			<view v-if="address" class="address-list" @click="onSkip(1)">
				<view class="list">
					<text>{{address.province}}{{address.city}}{{address.region}}</text>
				</view>
				<view class="list">
					<text class="address">{{address.detailAddress}}</text>
				</view>
				<view class="list">
					<text>{{address.name}}</text>
					<text>{{address.phoneNumber}}</text>
				</view>
				<view class="list">
					<text class="tips">(如果快递不方便接收，您可以选择暂时寄存服务)</text>
				</view>
			</view>
			<view v-else class="address-list" @click="onSkip()">
				<view class="list">
					<text class="tips">(如果快递不方便接收，您可以选择暂时寄存服务)</text>
				</view>
			</view>
			<view class="bar">

			</view>
		</view>
		<!-- 商品 -->
		<view class="goods-data">
			<view class="goods-title">
				<text>商品信息</text>
			</view>
			<view class="goods-list">
				<view class="list" v-for="(item,index) in productList" :key="index">
					<view class="thumb">
						<image :src="item.pic" mode=""></image>
					</view>
					<view class="item">
						<view class="title">
							<text class="name one-omit">{{item.name}}</text>
						</view>
						<view class="price-number">
							<view class="price">
								<text class="min">￥</text>
								<text class="max">{{String(item.price).split('.')[0]}}</text>
								<text class="min">.{{String(item.price).split('.')[1]?String(item.price).split('.')[1]:'00'}}</text>
							</view>
							<view class="number">
								<text>x {{item.stock}}</text>
							</view>
						</view>
					</view>
				</view>
			</view>
			<view class="delivery">
				<div class="list">
					<view class="title">配送</view>
					<view class="content">
						<text>快递运输</text>
						<text class="iconfont icon-more"></text>
					</view>
				</div>
				<div class="list">
					<view class="title">运费险</view>
					<view class="content">
						<text>￥10.00</text>
						<text class="iconfont icon-check"></text>
					</view>
				</div>
				<div class="list">
					<view class="title">留言</view>
					<view class="content">
						<input v-model="note" type="text" placeholder="选填,建议先和商家沟通确认">
					</view>
				</div>
			</view>
		</view>
		<!-- 优惠 -->
		<view class="discounts-data">
			<view class="discounts">
				<div class="list" @click="$refs['InvoiceInfo'].show()">
					<view class="title">发票</view>
					<view class="content">
						<text>不开发票</text>
						<text class="iconfont icon-more"></text>
					</view>
				</div>
				<div class="list" @click="$refs['UseCoupon'].show()">
					<view class="title">优惠券</view>
					<view class="content">
						<text v-if="!coupon">无可用</text>
						<text v-else>已减免￥{{coupon.amount}}</text>
						<text class="iconfont icon-more"></text>
					</view>
				</div>
				<div class="list">
					<view class="title">积分</view>
					<view class="content">
						<text>共300，满1000可用</text>
						<!-- <text class="iconfont icon-more"></text> -->
					</view>
				</div>
			</view>
		</view>
		<!-- 订单金额 -->
		<view class="order-price">
			<view class="price-list">
				<view class="list">
					<view class="title">
						<text>商品金额</text>
					</view>
					<view class="price">
						<text>￥{{productAmount}}</text>
					</view>
				</view>
				<view class="list">
					<view class="title">
						<text>优惠券减免</text>
					</view>
					<view class="price">
						<text class="highlight">-￥{{couponAmount}}</text>
					</view>
				</view>
			</view>
		</view>
		<!-- 地址提示 -->
		<view class="address-tips" :style="scrollTop >= 100 ? '':'display:none'">
			<text>{{address.province}}{{address.city}}{{address.region}}{{address.detailAddress}}</text>
		</view>
		<!-- 底部合计提交 -->
		<view class="footer-submit">
			<view class="price">
				<text class="min">￥</text>
				<text class="max">{{String(totalAmount).split('.')[0]}}</text>
				<text class="min">.{{String(totalAmount).split('.')[1]?String(totalAmount).split('.')[1]:'00'}}</text>
			</view>
			<view class="submit" @click="onSubmit">
				<text>提交订单</text>
			</view>
		</view>
		<!-- 发票 -->
		<invoice-info ref="InvoiceInfo"></invoice-info>
		<!-- 优惠券 -->
		<use-coupon ref="UseCoupon" @check-coupon="checkCoupon" :coupon-list="couponList"></use-coupon>
	</view>
</template>

<script>
	import InvoiceInfo from '../../components/InvoiceInfo/InvoiceInfo.vue';
	import UseCoupon from '../../components/UseCoupon/UseCoupon.vue'
	import productApi from '@/api/shop-product.js'
	import addressApi from '@/api/shop-user-address.js'
	import orderApi from '@/api/shop-order.js'
	import couponApi from '@/api/shop-coupon.js'
	export default {
		components: {
			// 发票
			InvoiceInfo,
			// 优惠券
			UseCoupon,
		},
		onLoad(param) {
			this.paramArr = JSON.parse(param.productArr)
			const tempAddress = param.address
			console.log(tempAddress)
			if (tempAddress) {
				this.address = JSON.parse(tempAddress)
			} else {
				this.getAddressList()
			}
			this.getProductByIds()
			this.getProductCoupon()
		},
		computed: {
			// 商品金额
			productAmount() {
				if (this.productList && this.productList[0]) {
					let price = 0
					this.productList.forEach(e=>{
						price = price + (e.price * e.stock)
					})
					return price
				} else {
					return 0
				}
			},
			// 优惠券减免
			couponAmount() {
				if(this.coupon) {
					return this.coupon.amount
				}else {
					return 0
				}
			},
			// 总金额
			totalAmount() {
				return this.productAmount - this.couponAmount
			}
		},
		data() {
			return {
				// 上一个页面传递来的数组
				paramArr: [],
				// 商品列表
				productList: [],
				// 优惠券列表
				couponList: [],
				// 收货地址
				address: {},
				// 备注
				note: '',
				// 优惠券
				coupon: null,
				scrollTop: 0,
			};
		},
		onPageScroll(e) {
			this.scrollTop = e.scrollTop;
		},
		methods: {
			// 选中优惠券触发
			checkCoupon(coupon) {
				this.coupon = coupon
			},
			// 加载收货地址
			getAddressList() {
				addressApi.getUserAddress().then(res => {
					const addressArr = res.data
					if (addressArr && addressArr[0]) {
						this.address = addressArr[0]
					}
				})
			},
			// 查询商品优惠券
			getProductCoupon() {
				couponApi.getProductCoupon(this.paramArr[0].productId).then(res=>{
					this.couponList = res.data
				})
			},
			// 根据id集合回显商品信息
			getProductByIds() {
				const productIds = []
				this.paramArr.forEach(e => {
					productIds.push(e.productId)
				})
				productApi.getByIds(productIds).then(res => {
					res.data.forEach(e => {
						const index = this.paramArr.findIndex(p => p.productId === e.id)
						e.stock = this.paramArr[index].count
						e.cartId = this.paramArr[index].cartId
					})
					this.productList = res.data
				})
			},
			/**
			 * 提交订单
			 */
			onSubmit() {
				const productList = this.productList.map(e=>{
					return {productId: e.id, count: e.stock, cartId: e.cartId}
				})
				// 构造参数
				const order = {
					productList: productList,
					addressId: this.address.id,
					note: this.note,
					couponId: this.coupon.id
				}
				orderApi.createOrder(order).then(res=>{
					uni.showToast({
						title:res.msg
					})
					setTimeout(()=>{
						uni.redirectTo({
							url: `/pages/CashierDesk/CashierDesk?id=${res.data.id}&amount=${res.data.payAmount}`,
						})
					}, 300)
				})
				
			},
			/**
			 * 跳转点击
			 * @param {String} type 跳转类型
			 */
			onSkip(type) {
				uni.navigateTo({
					url: `/pages/AddressList/AddressList?type=${type}&productArr=${JSON.stringify(this.paramArr)}`,
				})
			}
		}
	}
</script>

<style scoped lang="scss">
	@import 'ConfirmOrder.scss';
</style>

```



# 7. 订单操作

订单操作涉及到订单列表、状态变更等操作，功能虽多，但是复杂度却并不是很高

## 7.1 后端

### ShopOrderController

```java
    /**
     * 前台分页查询
     *
     * @param page
     * @return
     */
    @RequestMapping(value = "/getMyOrder", method = RequestMethod.POST)
    public Result<Page<ShopOrderVo>> getMyOrder(@RequestBody Page<ShopOrderVo> page) {
        page = shopOrderService.getMyOrder(page);
        return new Result<>(page);
    }

    /**
     * 根据ID查询
     *
     * @param id
     * @return
     */
    @RequestMapping(value = "/get/{id}", method = RequestMethod.GET)
    public Result<ShopOrderVo> get(@PathVariable Long id) {
        ShopOrderVo vo = shopOrderService.get(id);
        return new Result<>(vo);
    }

    /**
     * 根据id收货
     * @param id
     * @return
     */
    @RequestMapping(value = "/receiveById/{id}", method = RequestMethod.PUT)
    public Result<?> receiveById(@PathVariable Long id) {
        shopOrderService.receiveById(id);
        return new Result<>("收货成功");
    }
```



### ShopOrderService

```java
    /**
     * 分页查询前台用户订单列表
     * @param page
     * @return
     */
    Page<ShopOrderVo> getMyOrder(Page<ShopOrderVo> page);

    /**
     * 根据id查询
     * @param id
     * @return
     */
    ShopOrderVo get(Long id);

    /**
     * 根据id收货
     * @param id
     */
    void receiveById(Long id);
```



### ShopOrderServiceImpl

```java
    @Override
    public Page<ShopOrderVo> getMyOrder(Page<ShopOrderVo> page) {
        // 分页查询当前登录用户的订单列表
        LoginUser loginUser = ShiroUtils.getLoginUser();
        page.getParams().put("createBy", loginUser.getUsername());
        List<ShopOrder> list = shopOrderMapper.getByPage(page);
        Integer count = shopOrderMapper.getCountByPage(page);
        // 取出订单ID集合，查询每个订单的订单项信息
        if (!CollectionUtils.isEmpty(list)) {
            List<Long> orderIds = list.stream().map(ShopOrder::getId).collect(Collectors.toList());
            List<ShopOrderItem> itemList = shopOrderItemMapper.getByOrderIds(orderIds);
            List<ShopOrderVo> orderVoList = list.stream().map(o -> {
                ShopOrderVo vo = new ShopOrderVo();
                BeanUtils.copyProperties(o, vo);
                List<ShopOrderItem> orderItems = itemList.stream().filter(i -> i.getOrderId().equals(o.getId())).collect(Collectors.toList());
                vo.setItemList(orderItems);
                return vo;
            }).collect(Collectors.toList());
            page.setList(orderVoList);
        } else {
            page.setList(new ArrayList<>(0));
        }
        page.setTotalCount(count);
        return page;
    }

    @Override
    public ShopOrderVo get(Long id) {
        // 根据id查询订单
        ShopOrder order = shopOrderMapper.get(id);
        ShopOrderVo vo = new ShopOrderVo();
        BeanUtils.copyProperties(order, vo);
        // 根据订单id查询订单项
        List<ShopOrderItem> itemList = shopOrderItemMapper.getByOrderId(id);
        vo.setItemList(itemList);
        return vo;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void receiveById(Long id) {
        ShopOrder order = shopOrderMapper.get(id);
        order.setStatus(OrderStateEnum.ALREADY_SIGN.getCode());
        shopOrderMapper.updateOrderStatus(order);
        // 存储订单历史
        ShopOrderHistory orderHistory = new ShopOrderHistory();
        orderHistory.setId(idWorker.nextId());
        orderHistory.setOrderId(order.getId());
        orderHistory.setOperateMan(OperateEnum.USER.getType());
        orderHistory.setOrderStatus(OrderStateEnum.ALREADY_SIGN.getCode());
        shopOrderHistoryMapper.save(orderHistory);
    }
```



### ShopOrderMapper

```java
    /**
     * 分页查询
     * @param page
     * @return
     */
    List<ShopOrder> getByPage(Page<ShopOrderVo> page);

    /**
     * 查询总数
     * @param page
     * @return
     */
    Integer getCountByPage(Page<ShopOrderVo> page);
```



### ShopOrderMapper.xml

```xml
    <select id="getByPage" resultMap="BaseResultMap">
        select id,
        create_by,
        total_amount,
        pay_amount,
        freight_amount,
        coupon_amount,
        status,
        order_type,
        delivery_company,
        delivery_sn,
        auto_confirm_day,
        integration,
        receiver_name,
        receiver_phone,
        receiver_post_code,
        receiver_province,
        receiver_city,
        receiver_region,
        receiver_detail_address,
        confirm_status,
        payment_time,
        delivery_time,
        receive_time,
        comment_time,
        is_comment,
        create_time,
        update_time
        from shop_order
        where deleted = 0
        <if test="params.status!=null">
            and status = #{params.status}
        </if>
        <if test="params.createBy!=null and params.createBy!=''">
            and create_by = #{params.createBy}
        </if>
        order by create_time desc
        limit #{index}, #{pageSize}
    </select>
    <select id="getCountByPage" resultType="java.lang.Integer">
        select count(*)
        from shop_order
        where deleted = 0
        <if test="params.status!=null">
            and status = #{params.status}
        </if>
        <if test="params.createBy!=null and params.createBy!=''">
            and create_by = #{params.createBy}
        </if>
    </select>
```



### ShopOrderItemMapper

```java
    /**
     * 根据订单ID集合查询
     * @param orderIds
     * @return
     */
    List<ShopOrderItem> getByOrderIds(List<Long> orderIds);

    /**
     * 根据订单ID查询
     * @param id
     * @return
     */
    List<ShopOrderItem> getByOrderId(Long id);
```



### ShopOrderItemMapper.xml

```xml
    <select id="getByOrderIds" resultMap="BaseResultMap">
        select id,
        order_id,
        product_id,
        product_pic,
        product_name,
        product_brand,
        product_price,
        product_quantity
        from shop_order_item
        where order_id in (
        <foreach collection="list" separator="," item="item">
            #{item}
        </foreach>
        )
    </select>
    <select id="getByOrderId" resultMap="BaseResultMap">
        select id,
               order_id,
               product_id,
               product_pic,
               product_name,
               product_brand,
               product_price,
               product_quantity
        from shop_order_item
        where order_id = #{id}
    </select>
```

## 7.2 前端

### API

```js
import request from '@/utils/request'
const groupName = 'order'
export default {
	/**
	 * 创建订单
	 */
	createOrder(order) {
		return request({
			url: `/${groupName}/createOrder`,
			method: 'post',
			data: order
		})
	},
	/**
	 * 根据ID查询
	 * @param {Object} order
	 */
	get(id) {
		return request({
			url: `/${groupName}/get/${id}`,
			method: 'get'
		})
	},
	/**
	 * 确认收货
	 * @param {Object} order
	 */
	receiveById(id) {
		return request({
			url: `/${groupName}/receiveById/${id}`,
			method: 'put'
		})
	},
	/**
	 * 查询我的订单
	 */
	getMyOrder(order) {
		return request({
			url: `/${groupName}/getMyOrder`,
			method: 'post',
			data: order
		})
	},
	/**
	 * 创建支付订单
	 */
	createPayOrder(order) {
		return request({
			url: `/${groupName}/createPayOrder`,
			method: 'post',
			data: order
		})
	}
}

```

### 列表页

```vue
<template>
	<view class="page">
		<view class="head-back">
			<view class="back" @click="onBack">
				<text></text>
			</view>
			<view class="title">
				<text>我的订单</text>
			</view>
			<view class="more-icon">
				<view class="icon-list">
					<text class="iconfont icon-fadajing"></text>
				</view>
			</view>
		</view>
		<!-- 订单tab -->
		<view class="order-tab">
			<view class="tab" :class="{'action':orderStatus==999}" @click="onOrderTab(999)">
				<text>全部</text>
				<text class="line"></text>
			</view>
			<view class="tab" :class="{'action':orderStatus==0}" @click="onOrderTab(0)">
				<text>待付款</text>
				<text class="line"></text>
			</view>
			<view class="tab" :class="{'action':orderStatus==2}" @click="onOrderTab(2)">
				<text>待发货</text>
				<text class="line"></text>
			</view>
			<view class="tab" :class="{'action':orderStatus==3}" @click="onOrderTab(3)">
				<text>待收货</text>
				<text class="line"></text>
			</view>
			<view class="tab" :class="{'action':orderStatus==4}" @click="onOrderTab(4)">
				<text>待评价</text>
				<text class="line"></text>
			</view>
		</view>
		<!-- 订单列表 -->
		<view class="order-list">
			<view class="list" v-for="(item,index) in dataPage.list" @click="onOrderList(item.id)" :key="index">
				<view class="title-status">
					<view class="title">
						<text>下单时间：{{item.createTime}}</text>
					</view>
					<view class="status">
						<text>{{orderStatus[item.status]}}</text>
						<text class="iconfont icon-laji del"></text>
					</view>
				</view>
				<view class="goods-list">
					<view class="goods" v-for="(product, i) in item.itemList" :key="i">
						<view class="thumb">
							<image :src="product.productPic" mode=""></image>
						</view>
						<view class="item">
							<view class="goods-name">
								<text class="two-omit">{{product.productName}}</text>
							</view>
							<view class="goods-price">
								<text class="min">￥</text>
								<text class="max">{{String(product.productPrice).split('.')[0]}}</text>
								<text class="min">.{{String(product.productPrice).split('.')[1]?String(product.productPrice).split('.')[1]:'00'}}</text>
							</view>
						</view>
					</view>
				</view>
				<view class="status-btn">
					<view class="btn">
						<text>取消订单</text>
					</view>
					<view v-if="item.status === 4" class="btn action" @click.stop="onEvaluate">
						<text>评价</text>
					</view>
				</view>
			</view>
		</view>
	</view>
</template>

<script>
	import orderApi from '@/api/shop-order.js'
	export default {
		data() {
			return {
				orderStatus: 0,
				// 分页查询参数
				page: {
					// 当前页
					pageNumber: 1,
					// 每页条数
					pageSize: 20,
					// 查询参数
					params: {}
				},
				// 订单状态
				orderStatus: {
					0:'待付款',
					1:'待确认',
					2:'待发货',
					3:'待签收',
					4:'待评价',
					5:'已完成',
					6:'已失效',
					7:'已关闭'
				},
				// 数据分页对象
				dataPage: {
					list: []
				}
			};
		},
		watch: {
			orderStatus: {
				immediate: true,
				handler: function() {
					if(this.orderStatus !== 999) {
						this.page.params.status = this.orderStatus
					}else {
						this.page.params.status = null
					}
					this.getMyOrder()
				}
			}
		},
		onLoad(params) {
			let type = params.type
			if(!type) {
				type = 999
			}
			this.orderStatus = type;
		},
		methods: {
			// 查询我的订单
			getMyOrder() {
				orderApi.getMyOrder(this.page).then(res => {
					this.dataPage = res.data
				})
			},
			/**
			 * 返回点击
			 */
			onBack() {
				uni.navigateBack();
			},
			/**
			 * 订单tab点击
			 */
			onOrderTab(type) {
				this.orderStatus = type;
				// #ifdef H5
				uni.redirectTo({
					url: '/pages/MyOrderList/MyOrderList?type=' + type,
				})
				//#endif
			},
			/**
			 * 订单列表点击
			 */
			onOrderList(id) {
				uni.navigateTo({
					url: '/pages/OrderDetails/OrderDetails?id='+id,
				})
			},
			/**
			 * 评价点击
			 */
			onEvaluate() {
				uni.navigateTo({
					url: '/pages/MyEvaluatePush/MyEvaluatePush'
				})
			}
		}
	}
</script>

<style scoped lang="scss">
	@import 'MyOrderList.scss';
</style>

```

### 详情页

```vue
<template>
	<view class="page">
		<!-- 订单状态 -->
		<view class="order-status">
			<view class="status">
				<text class="iconfont icon-zhuyi"></text>
				<text>{{orderStatus[order.status]}}</text>
			</view>
			<view class="reason">
				<text>剩余12分68秒</text>
			</view>
		</view>
		<!-- 收货地址 -->
		<view class="shipping-address">
			<view class="name-phone">
				<text class="iconfont icon-dingwei"></text>
				<text>{{order.receiverName}}</text>
				<text>{{order.receiverPhone}}</text>
			</view>
			<view class="address">
				<text>{{order.receiverProvince}}{{order.receiverCity}}{{order.receiverRegion}}{{order.receiverDetailAddress}}</text>
			</view>
		</view>
		<!-- 订单商品 -->
		<view class="order-goods">
			<view class="goods-list">
				<view class="list" v-for="(item,index) in order.itemList" :key="index">
					<view class="thumb">
						<image :src="item.productPic" mode=""></image>
					</view>
					<view class="item">
						<view class="title">
							<text class="one-omit">{{item.productName}}</text>
						</view>
						<view class="num-size">
							<text>数量：{{item.productQuantity}}</text>
						</view>
						<view class="price">
							<text>￥{{item.productPrice}}</text>
						</view>
						<view class="order-btn">
							<view class="btn" @click="onApplyAftersales">
								<text>申请售后</text>
							</view>
						</view>
					</view>
				</view>
			</view>
			<view class="contact">
				<text class="iconfont icon-kefu"></text>
				<text>联系客服</text>
			</view>
		</view>
		<!-- 订单信息 -->
		<view class="order-info">
			<view class="info-list">
				<view class="list">
					<view class="title">订单编号:</view>
					<view class="content">
						<text>{{order.id}}</text>
						<text class="btn">复制</text>
					</view>
				</view>
				<view class="list">
					<view class="title">下单时间:</view>
					<view class="content">
						<text>{{order.createTime}}</text>
					</view>
				</view>
				<view class="list">
					<view class="title">支付方式:</view>
					<view class="content">
						<text>微信支付</text>
					</view>
				</view>
				<view class="list">
					<view class="title">配送方式:</view>
					<view class="content">
						<text>普通快递</text>
					</view>
				</view>
				<view class="list">
					<view class="title">配送日期:</view>
					<view class="content">
						<text>2020-11-11</text>
					</view>
				</view>
			</view>
		</view>
		<!-- 订单明细 -->
		<view class="order-details">
			<view class="details-list">
				<view class="list">
					<view class="title">
						<text>商品总额</text>
					</view>
					<view class="price">
						<text>￥{{order.totalAmount}}</text>
					</view>
				</view>
				<view class="list">
					<view class="title">
						<text>运费</text>
					</view>
					<view class="price">
						<text>+￥0.00</text>
					</view>
				</view>
				<view class="list action">
					<view class="title">
						<text>实付款：</text>
					</view>
					<view class="price">
						<text>￥{{order.payAmount}}</text>
					</view>
				</view>
			</view>
		</view>
		<!-- 底部按钮 -->
		<view class="footer-btn">
			<view class="del">
				<text>删除订单</text>
			</view>
			<view class="btn">
				<text>查看发票</text>
				<text class="action" v-if="order.status === 0" @click="pay">确认付款</text>
				<text class="action" v-if="order.status === 3" @click="confirmSign">确认收货</text>
			</view>
		</view>
	</view>
</template>

<script>
	import orderApi from '@/api/shop-order.js'
	export default {
		data() {
			return {
				// 订单对象
				order: {},
				// 订单ID
				orderId: null,
				
				// 订单状态
				orderStatus: {
					0:'待付款',
					1:'待确认',
					2:'待发货',
					3:'待签收',
					4:'待评价',
					5:'已完成',
					6:'已失效',
					7:'已关闭'
				},
			};
		},
		onLoad(param) {
			this.orderId = param.id
			this.getById()
		},
		methods:{
			// 根据id查询
			getById() {
				orderApi.get(this.orderId).then(res=>{
					this.order = res.data
				})
			},
			// 确认收货
			confirmSign() {
				orderApi.receiveById(this.orderId).then(res=>{
					uni.showToast({
						title:res.msg
					})
					setTimeout(()=>{
						uni.navigateTo({
							url:'/pages/MyOrderList/MyOrderList'
						})
					}, 300)
				})
			},
			// 支付
			pay() {
				// 测试方法
				uni.requestSubscribeMessage({
					tmplIds: ['mR8UIyXR7PAEvE9n-zJpPHVV5it3-5qtRECfSOfXvAQ'],
					success: (res) => {
						// 调用支付接口
						orderApi.createPayOrder({
							id: this.orderId
						}).then(res => {
							uni.requestPayment({
								...res.data,
								complete: (res) => {
									uni.redirectTo({
										url: `/pages/PayResult/PayResult?amount=${this.payAmount}`,
									})
								}
							})
						})
					}
				})
			},
			/**
			 * 售后点击
			 */
			onApplyAftersales(){
				uni.navigateTo({
					url: '/pages/AfterSaleType/AfterSaleType',
				})
			}
		}
	}
</script>

<style scoped lang="scss">
	@import 'OrderDetails.scss';
</style>

```



# 8. 订单评价

评价功能我个人认为属于不太重要的数据，因此这里我们存到mongodb中。实际场景下请大家根据业务需求决定是存到mongodb还是存到mysql，评价数据存到二者之中皆可。

订单的每一步操作都是基于整个大订单进行，但是评价还需要基于商品，因为评价的不仅仅是订单，还是商品。

## 8.1 后端

### ShopOrderComment

```java
package com.jg.pochi.pojo;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import java.io.Serializable;

/**
 * @Author: 杨德石
 * @Date: 2021/1/23 22:07
 * @Version 1.0
 */
@Data
@Document(collection = "shop_order_comment")
public class ShopOrderComment implements Serializable {

    @Id
    @Field("id")
    private Long id;

    @Field("product_id")
    private Long productId;

    @Field("order_id")
    private Long orderId;

    @Field("order_item_id")
    private Long orderItemId;

    @Field("comment_id")
    private Long commentId;

    @Field("comment_type")
    private Integer commentType;

    @Field("nick_name")
    private String nickName;

    @Field("product_name")
    private String productName;

    @Field("star")
    private Integer star;

    @Field("create_time")
    private String createTime;

    @Field("content")
    private String content;

    @Field("pics")
    private String pics;

    @Field("member_icon")
    private String memberIcon;

}

```

### ShopOrderCommentDto

因为评价涉及到上传图片，这里我们提供一个dto

```java
package com.jg.pochi.pojo.dto;

import lombok.Data;

import java.io.Serializable;
import java.util.List;

/**
 * @Author: 杨德石
 * @Date: 2021/1/23 22:12
 * @Version 1.0
 */
@Data
public class ShopOrderCommentDto implements Serializable {

    private Long orderItemId;

    private Long orderId;

    private Long commentId;

    private Integer commentType;

    private Integer star;

    private String content;

    private List<String> picList;

}

```



### ShopOrderCommentController

```java
package com.jg.pochi.controller;

import com.jg.pochi.common.Page;
import com.jg.pochi.common.Result;
import com.jg.pochi.pojo.ShopOrder;
import com.jg.pochi.pojo.ShopOrderComment;
import com.jg.pochi.pojo.dto.ShopOrderCommentDto;
import com.jg.pochi.service.ShopOrderCommentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.awt.print.Pageable;
import java.util.List;

/**
 * @Author: 杨德石
 * @Date: 2021/1/23 22:14
 * @Version 1.0
 */
@RestController
@RequestMapping("/orderComment")
public class ShopOrderCommentController {

    @Autowired
    private ShopOrderCommentService shopOrderCommentService;

    /**
     * 前台评价
     * @param list
     * @return
     */
    @RequestMapping(value = "/save",method = RequestMethod.POST)
    public Result<?> save(@RequestBody List<ShopOrderCommentDto> list) {
        shopOrderCommentService.save(list);
        return new Result<>("评价成功");
    }

    /**
     * 分页查询
     * @param page
     * @return
     */
    @RequestMapping(value = "/getByPage", method = RequestMethod.POST)
    public Result<Page<ShopOrderComment>> getByPage(@RequestBody Page<ShopOrderComment> page) {
        page = shopOrderCommentService.getByPage(page);
        return new Result<>(page);
    }

}

```

### ShopOrderCommentService

```java
package com.jg.pochi.service;

import com.jg.pochi.common.Page;
import com.jg.pochi.pojo.ShopOrderComment;
import com.jg.pochi.pojo.dto.ShopOrderCommentDto;

import java.util.List;

/**
 * @Author: 杨德石
 * @Date: 2021/1/23 22:14
 * @Version 1.0
 */
public interface ShopOrderCommentService {
    /**
     * 前台评价
     *
     * @param list
     */
    void save(List<ShopOrderCommentDto> list);

    /**
     * 分页查询
     *
     * @param page
     * @return
     */
    Page<ShopOrderComment> getByPage(Page<ShopOrderComment> page);
}

```

### ShopOrderCommentServiceImpl

```java
package com.jg.pochi.service.impl;

import com.jg.pochi.common.Page;
import com.jg.pochi.enums.OperateEnum;
import com.jg.pochi.enums.OrderStateEnum;
import com.jg.pochi.enums.StateEnums;
import com.jg.pochi.mapper.ShopOrderHistoryMapper;
import com.jg.pochi.mapper.ShopOrderItemMapper;
import com.jg.pochi.mapper.ShopOrderMapper;
import com.jg.pochi.pojo.ShopOrder;
import com.jg.pochi.pojo.ShopOrderComment;
import com.jg.pochi.pojo.ShopOrderHistory;
import com.jg.pochi.pojo.ShopOrderItem;
import com.jg.pochi.pojo.dto.ShopOrderCommentDto;
import com.jg.pochi.pojo.vo.ShopOrderCommentVo;
import com.jg.pochi.repository.ShopOrderCommentRepository;
import com.jg.pochi.service.ShopOrderCommentService;
import com.jg.pochi.shiro.LoginUser;
import com.jg.pochi.utils.DateUtils;
import com.jg.pochi.utils.IdWorker;
import com.jg.pochi.utils.ShiroUtils;
import com.jg.pochi.utils.StringUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @Author: 杨德石
 * @Date: 2021/1/23 22:14
 * @Version 1.0
 */
@Service
public class ShopOrderCommentServiceImpl implements ShopOrderCommentService {

    @Autowired
    private ShopOrderCommentRepository shopOrderCommentRepository;
    @Autowired
    private ShopOrderItemMapper shopOrderItemMapper;
    @Autowired
    private ShopOrderMapper shopOrderMapper;
    @Autowired
    private ShopOrderHistoryMapper shopOrderHistoryMapper;
    @Autowired
    private IdWorker idWorker;
    @Autowired
    private MongoTemplate mongoTemplate;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void save(List<ShopOrderCommentDto> list) {
        LoginUser loginUser = ShiroUtils.getLoginUser();
        // 将DTO转换成pojo
        List<ShopOrderComment> commentList = list.stream().map(e -> {
            ShopOrderComment comment = new ShopOrderComment();
            BeanUtils.copyProperties(e, comment);
            comment.setId(idWorker.nextId());
            comment.setMemberIcon(loginUser.getHeader());
            comment.setNickName(loginUser.getNickName());
            comment.setCreateTime(DateUtils.newDateTime());
            comment.setCommentType(StateEnums.COMMENT_SIMPLE.getCode());
            // 处理图片
            if (!CollectionUtils.isEmpty(e.getPicList())) {
                comment.setPics(StringUtils.join(e.getPicList(), ","));
            }
            return comment;
        }).collect(Collectors.toList());

        List<Long> orderItemIds = list.stream().map(ShopOrderCommentDto::getOrderItemId).collect(Collectors.toList());
        List<ShopOrderItem> orderItemList = shopOrderItemMapper.getByIds(orderItemIds);
        commentList.forEach(e -> {
            ShopOrderItem orderItem = orderItemList.stream().filter(i -> i.getId().equals(e.getOrderItemId())).findFirst().orElse(new ShopOrderItem());
            e.setProductId(orderItem.getProductId());
            e.setProductName(orderItem.getProductName());
        });
        // 订单状态改为已评价，保存订单操作历史
        shopOrderCommentRepository.saveAll(commentList);
        ShopOrder order = shopOrderMapper.get(list.get(0).getOrderId());
        order.setStatus(OrderStateEnum.FINISH.getCode());
        shopOrderMapper.updateOrderStatus(order);
        // 存储订单历史
        ShopOrderHistory orderHistory = new ShopOrderHistory();
        orderHistory.setId(idWorker.nextId());
        orderHistory.setOrderId(order.getId());
        orderHistory.setOperateMan(OperateEnum.USER.getType());
        orderHistory.setOrderStatus(OrderStateEnum.FINISH.getCode());
        shopOrderHistoryMapper.save(orderHistory);
    }

    @Override
    public Page<ShopOrderCommentVo> getByPage(Page<ShopOrderCommentVo> page) {
        Query query = new Query();
        // 设置参数
        Map<String, Object> params = page.getParams();
        Object productId = params.get("productId");
        if (productId != null) {
            query.addCriteria(Criteria.where("product_id").is(Long.parseLong(productId.toString())));
        }
        Object orderId = params.get("orderId");
        if (orderId != null) {
            query.addCriteria(Criteria.where("order_id").is(Long.parseLong(orderId.toString())));
        }
        int count = (int) mongoTemplate.count(query, ShopOrderComment.class);
        // 构造分页
        query.skip(page.getIndex());
        query.limit(page.getPageSize());
        // 构造排序条件
        Sort.Order order = new Sort.Order(Sort.Direction.DESC, "create_time");
        query.with(Sort.by(order));
        List<ShopOrderComment> list = mongoTemplate.find(query, ShopOrderComment.class);
        if (!CollectionUtils.isEmpty(list)) {
            List<ShopOrderCommentVo> voList = list.stream().map(e -> {
                ShopOrderCommentVo vo = new ShopOrderCommentVo();
                BeanUtils.copyProperties(e, vo);
                if (StringUtils.isNotBlank(e.getPics())) {
                    vo.setPicList(Arrays.asList(e.getPics().split(",")));
                }
                return vo;
            }).collect(Collectors.toList());
            page.setList(voList);
        } else {
            page.setList(new ArrayList<>(0));
        }
        page.setTotalCount(count);
        return page;
    }
}

```

### ShopOrderCommentRepository

```java
package com.jg.pochi.dao;

import com.jg.pochi.pojo.ShopOrderComment;
import org.springframework.data.mongodb.repository.MongoRepository;

/**
 * @Author: 杨德石
 * @Date: 2020/11/4 22:21
 * @Version 1.0
 */
public interface ShopOrderCommentRepository extends MongoRepository<ShopOrderComment, Long> {
}

```

## 8.2 前端-评价

```vue
<template>
	<view class="page">
		<div class="comment-list" v-for="(item, index) in commentList" :key="index">
			<view class="evaluate-goods">
				<view class="list">
					<view class="picture">
						<image :src="item.productPic"></image>
					</view>
					<view class="item">
						<view class="title">
							<text>商品评价</text>
						</view>
						<view class="star-list">
							<view class="star">
								<text @tap="changeStar(item, 1)" class="cuIcon-favorfill lg text-gray" :class="item.star >= 1?'ac':''"></text>
								<text @tap="changeStar(item, 2)" class="cuIcon-favorfill lg text-gray" :class="item.star >= 2?'ac':''"></text>
								<text @tap="changeStar(item, 3)" class="cuIcon-favorfill lg text-gray" :class="item.star >= 3?'ac':''"></text>
								<text @tap="changeStar(item, 4)" class="cuIcon-favorfill lg text-gray" :class="item.star >= 4?'ac':''"></text>
								<text @tap="changeStar(item, 5)" class="cuIcon-favorfill lg text-gray" :class="item.star >= 5?'ac':''"></text>
							</view>
							<view class="hint">
								<text>满意</text>
							</view>
						</view>
					</view>
				</view>
			</view>
			<!--填写-->
			<view class="input-info">
				<view class="input-title">
					<text>分享你的使用体验吧</text>
				</view>
				<view class="input-text">
					<textarea v-model="item.content" placeholder="感觉怎么？跟大家分享一下吧~"></textarea>
					<view class="record-text">
						<text>已写</text>
						<text class="ac">12</text>
						<text>个字</text>
					</view>
				</view>
				<view class="anonymous">
					<radio class="radio" :checked="isChecked" color="red" style="transform:scale(0.7)"></radio>
					<text>匿名评价</text>
				</view>
			</view>
			<!--上传图片-->
			<view class="upload-img">
				<view class="img-title">
					<text>上传图片</text>
				</view>
				<view class="img-list">
					<view class="list up-img" @click="toUpload(item)">
						<image src="/static/up_img.png"></image>
					</view>
					<view class="list" v-for="(img, index) in item.picList" :key="index">
						<image :src="img"></image>
						<text class="iconfont icon-close1" @tap="closeImg(item, img)"></text>
					</view>
				</view>
			</view>
		</div>
		<!--提交-->
		<view class="submit-btn" @click="submitComment">
			<view class="btn">
				<text>提交</text>
			</view>
		</view>
	</view>
</template>

<script>
	import commentApi from '@/api/shop-order-comment.js'
	export default {
		data() {
			return {
				isChecked: false,
				// 评论列表
				commentList: []
			};
		},
		onLoad(param) {
			const itemList = JSON.parse(param.itemList)
			const commentList = itemList.map(e => {
				return {
					orderItemId: e.id,
					orderId: e.orderId,
					star: 5,
					productPic: e.productPic,
					picList: []
				}
			})
			this.commentList = commentList
		},
		methods: {
			// 点击评分
			changeStar(item, star) {
				console.log(item, star)
				item.star = star
			},
			// 删除图片
			closeImg(item, url) {
				item.picList.splice(
					item.picList.findIndex(e => e === url), 1
				)
			},
			// 提交评价
			submitComment() {
				commentApi.save(this.commentList).then(res=>{
					uni.showToast({
						title:res.msg
					})
					setTimeout(()=>{
						uni.navigateBack()
					},300)
				})
			},
			// 上传图片
			toUpload(item) {
				uni.chooseImage({
					count: 3,
					success: (res) => {
						const fileUrls = res.tempFilePaths
						if (fileUrls.length + item.picList.length > 3) {

						} else {
							fileUrls.forEach(fileUrl => {
								uni.uploadFile({
									url: 'http://localhost:8080/upload/uploadFile',
									filePath: fileUrl,
									name: 'file',
									header: {
										Authorization: uni.getStorageSync('Authorization')
									},
									formData: {
										dir: 'brand'
									},
									success: (res) => {
										const url = JSON.parse(res.data).data
										item.picList.push(url)
									},
									fail: () => {
										console.log('上传失败')
									}
								})
							})
						}
					}
				})
			}
		}
	}
</script>

<style scoped lang="scss">
	@import "MyEvaluatePush.scss";
</style>

```



## 8.3 前端-评价列表

```vue
		<!-- 评价 -->
		<view class="evaluate-data" ref="evaluate">
			<view class="title-more" @click="onEvaluate">
				<view class="title">
					<text>评价</text>
					<text class="num" v-if="commentDataPage.totalCount <= 999">{{commentDataPage.totalCount}}</text>
					<text class="num" v-else>999+</text>
				</view>
				<view class="more">
					<text class="iconfont icon-more"></text>
				</view>
			</view>
			<view class="evaluate-list" v-for="(comment, ci) in commentDataPage.list" :key="ci">
				<view class="user-info">
					<view class="thumb">
						<image :src="comment.memberIcon" mode=""></image>
					</view>
					<view class="nickname-grade">
						<view class="nickname">
							<text>{{comment.nickName}}</text>
						</view>
						<view class="grade">
							<text v-for="star in comment.star" :key="star" class="cuIcon-favorfill lg text-gray"></text>
						</view>
					</view>
				</view>
				<view class="content">
					<view class="character">
						<text class="two-omit">{{comment.content}}</text>
					</view>
					<view class="thumb-list">
						<view class="list" v-for="(pic, pi) in comment.picList" :key="pi">
							<image :src="pic" mode=""></image>
						</view>
					</view>
				</view>
				<view class="look-all" @click="onEvaluate">
					<text>查看全部评价</text>
				</view>
			</view>
		</view>

			// 查询商品评价
			getComment() {
				this.commentPage.params.productId = this.productId
				commentApi.getByPage(this.commentPage).then(res=>{
					this.commentDataPage = res.data
				})
			},
```




